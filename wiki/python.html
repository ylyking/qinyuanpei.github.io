
  
    <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Python快速教程 | 秦元培</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="秦元培">
    

    
    <meta name="description" content="前言Python语言可能是第一种即简单又功能强大的编程语言。它不仅适合于初学者，也适合于专业人员使用，更加重要的是，用Python编程是一种愉快的事。本身将帮助你学习这个奇妙的语言，并且向你展示如何即快捷又方便地完成任务——真正意义上“为编程问题提供的完美解决方案！”
本书的读者本书可以作为Python编程语言的一本指南或者教程。它主要是为新手而设计，不过对于有经验的程序员来说，它同样有用。
即便">
<meta property="og:type" content="website">
<meta property="og:title" content="Python快速教程">
<meta property="og:url" content="http://qinyuanpei.com/wiki/python.html">
<meta property="og:site_name" content="秦元培">
<meta property="og:description" content="前言Python语言可能是第一种即简单又功能强大的编程语言。它不仅适合于初学者，也适合于专业人员使用，更加重要的是，用Python编程是一种愉快的事。本身将帮助你学习这个奇妙的语言，并且向你展示如何即快捷又方便地完成任务——真正意义上“为编程问题提供的完美解决方案！”
本书的读者本书可以作为Python编程语言的一本指南或者教程。它主要是为新手而设计，不过对于有经验的程序员来说，它同样有用。
即便">
<meta property="og:updated_time" content="2015-12-06T13:54:54.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python快速教程">
<meta name="twitter:description" content="前言Python语言可能是第一种即简单又功能强大的编程语言。它不仅适合于初学者，也适合于专业人员使用，更加重要的是，用Python编程是一种愉快的事。本身将帮助你学习这个奇妙的语言，并且向你展示如何即快捷又方便地完成任务——真正意义上“为编程问题提供的完美解决方案！”
本书的读者本书可以作为Python编程语言的一本指南或者教程。它主要是为新手而设计，不过对于有经验的程序员来说，它同样有用。
即便">

    
    <link rel="alternative" href="/atom.xml" title="秦元培" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

      <body>
        <header>
          
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="秦元培">秦元培</a></h1>
				<h2 class="blog-motto">仰天大笑出门去，我辈岂是蓬蒿人</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:qinyuanpei.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
        </header>
        <div id="container">
          <div id="main" class="page" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/wiki/python.html" title="Python快速教程" itemprop="url">Python快速教程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="秦元培" target="_blank" itemprop="author">秦元培</a>
		
    <p class="article-time">
    <time datetime="2015-10-14T02:16:54.000Z" itemprop="datePublished"> 发表于 2015-10-14</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h1 id="前言">前言</h1><p>Python语言可能是第一种即简单又功能强大的编程语言。它不仅适合于初学者，也适合于专业人员使用，更加重要的是，用Python编程是一种愉快的事。本身将帮助你学习这个奇妙的语言，并且向你展示如何即快捷又方便地完成任务——真正意义上“为编程问题提供的完美解决方案！”</p>
<h2 id="本书的读者">本书的读者</h2><p>本书可以作为Python编程语言的一本指南或者教程。它主要是为新手而设计，不过对于有经验的程序员来说，它同样有用。</p>
<p>即便你对计算机的了解只是如何在计算机上保存文本文件，你都可以通过本书学习Python。如果你有编程经验，你也可以使用本书学习Python。</p>
<p>如果你以前有编程经验，那么你将会对Python语言和其他你所钟爱的编程语言之间的区别感兴趣。对此我为你指出了许多这样的区别。顺便提醒你，Python将很快成为你最喜欢的编程语言！</p>
<h2 id="本书的由来">本书的由来</h2><p>我最初接触Python是当我需要为我的软件<del><a href="http://www.g2swaroop.net/software/" target="_blank" rel="external">钻石</a></del>写一个方便安装过程的安装程序的时候。我得在Python和Perl语言中选择一个绑定Qt库。我在网上做了一些研究，偶然发现了一篇文章。那是Eric S. Raymond（著名的电脑高手）谈Python如何成为它最喜欢地编程语言的一篇文章。我同时发现PyQt绑定与Perl-Qt相比要出色得多，所以我选择了Python语言。</p>
<h2 id="本书目前的状况">本书目前的状况</h2><p>本书目前仍然在 <strong>进一步完善</strong> 中。许多章节已经频繁地做了修改。然而本书已经十分成熟了，你一定可以很容易地通过它学习Python。如果你觉得本书中有什么错误或者难懂的地方，请告诉我。</p>
<p>本书将来计划增加更多的章节，包括wxPython，Twisted，有可能的话甚至还有Boa Constructor。</p>
<h2 id="官方网站">官方网站</h2><p>本书的官方网站是<a href="http://www.byteofpython.info/" target="_blank" rel="external">www.byteofpython.info</a>。你可以在这个网站上在线阅读本书，也可以下载本书的最新版本或给我反馈。</p>
<h2 id="约定条款">约定条款</h2><p>本书（原版）依照创作共用约定（<a href="http://www.creativecommons.org/licenses/by-nd-nc/1.0/deed.zh" target="_blank" rel="external">署名-非商业作品-保持一致</a>）发布。简单地说，你只要署上我的名字，就可以免费复制、分发和展示本书。未得到我的允许，你禁止把本书用于商业目的。你在修改本书的时候，必须清楚地标明所有做了改动的地方，你发布修改后的作品时也必须遵照与本书相同的约定。</p>
<p>请访问<a href="http://creativecommons.org/licenses/by-nc-sa/2.0/" target="_blank" rel="external">创作公用约定</a>的网站浏览约定全文，或者查看一个简单易懂的约定描述。那里还有一个连环画似的约定条款的解释。</p>
<h2 id="反馈">反馈</h2><p>我尽了很大的力让这本书即生动又尽可能的准确。然而，如果你找到任何不太令你满意的地方或者错误，或者是需要改进的地方，请告诉我以便我改正它们。你可以把它们通过<code>swaroop@byteofpython.info</code>发送给我。</p>
<h2 id="值得思考的一些东西">值得思考的一些东西</h2><blockquote>
<p>有两种方式构建软件设计：一种是把软件做得很简单以至于明显找不到缺陷；另一种是把它做得很复杂以至于找不到明显的缺陷。</p>
</blockquote>
<p><em>C.A.R. Hoare</em></p>
<blockquote>
<p>获得人生中的成功需要的专注与坚持不懈多过天才与机会。</p>
</blockquote>
<p><em>C.W. Wendte</em></p>
<h1 id="介绍">介绍</h1><h2 id="简介">简介</h2><p>Python语言是少有的一种可以称得上即 <strong>简单</strong> 又 <strong>功能强大</strong> 的编程语言。你将惊喜地发现Python语言是多么地简单，它注重的是如何解决问题而不是编程语言的语法和结构。</p>
<p>Python的官方介绍是：</p>
<blockquote>
<p>Python是一种简单易学，功能强大的编程语言，它有高效率的高层数据结构，简单而有效地实现面向对象编程。Python简洁的语法和对动态输入的支持，再加上解释性语言的本质，使得它在大多数平台上的许多领域都是一个理想的脚本语言，特别适用于快速的应用程序开发。</p>
</blockquote>
<p>我会在下一节里详细地讨论Python的这些特点。</p>
<blockquote>
<p><strong>注释</strong></p>
<p>Python语言的创造者Guido van Rossum是根据英国广播公司的节目“蟒蛇飞行马戏”命名这个语言的，并非他本人特别喜欢蛇缠起它们的长身躯碾死动物觅食。</p>
</blockquote>
<h2 id="Python的特色">Python的特色</h2><h3 id="简单">简单</h3><p>Python是一种代表简单主义思想的语言。阅读一个良好的Python程序就感觉像是在读英语一样，尽管这个英语的要求非常严格！Python的这种伪代码本质是它最大的优点之一。它使你能够专注于解决问题而不是去搞明白语言本身。</p>
<h3 id="易学">易学</h3><p>就如同你即将看到的一样，Python极其容易上手。前面已经提到了，Python有极其简单的语法。</p>
<h3 id="免费、开源">免费、开源</h3><p>Python是FLOSS（自由/开放源码软件）之一。简单地说，你可以自由地发布这个软件的拷贝、阅读它的源代码、对它做改动、把它的一部分用于新的自由软件中。FLOSS是基于一个团体分享知识的概念。这是为什么Python如此优秀的原因之一——它是由一群希望看到一个更加优秀的Python的人创造并经常改进着的。</p>
<h3 id="高层语言">高层语言</h3><p>当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节。</p>
<h3 id="可移植性">可移植性</h3><p>由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行。</p>
<p>这些平台包括Linux、Windows、FreeBSD、Macintosh、Solaris、OS/2、Amiga、AROS、AS/400、BeOS、OS/390、z/OS、Palm OS、QNX、VMS、Psion、Acom RISC OS、VxWorks、PlayStation、Sharp Zaurus、Windows CE甚至还有PocketPC！</p>
<h3 id="解释性">解释性</h3><p>这一点需要一些解释。</p>
<p>一个用编译性语言比如C或C++写的程序可以从源文件（即C或C++语言）转换到一个你的计算机使用的语言（二进制代码，即0和1）。这个过程通过编译器和不同的标记、选项完成。当你运行你的程序的时候，连接/转载器软件把你的程序从硬盘复制到内存中并且运行。</p>
<p>而Python语言写的程序不需要编译成二进制代码。你可以直接从源代码 运行 程序。在计算机内部，Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。事实上，由于你不再需要担心如何编译程序，如何确保连接转载正确的库等等，所有这一切使得使用Python更加简单。由于你只需要把你的Python程序拷贝到另外一台计算机上，它就可以工作了，这也使得你的Python程序更加易于移植。</p>
<h3 id="面向对象">面向对象</h3><p>Python即支持面向过程的编程也支持面向对象的编程。在 <strong>面向过程</strong> 的语言中，程序是由过程或仅仅是可重用代码的函数构建起来的。在 <strong>面向对象</strong> 的语言中，程序是由数据和功能组合而成的对象构建起来的。与其他主要的语言如C++和Java相比，Python以一种非常强大又简单的方式实现面向对象编程。</p>
<h3 id="可扩展性">可扩展性</h3><p>如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。</p>
<h3 id="可嵌入性">可嵌入性</h3><p>你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能。</p>
<h3 id="丰富的库">丰富的库</h3><p>Python标准库确实很庞大。它可以帮助你处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI（图形用户界面）、Tk和其他与系统有关的操作。记住，只要安装了Python，所有这些功能都是可用的。这被称作Python的“功能齐全”理念。</p>
<p>除了标准库以外，还有许多其他高质量的库，如<a href="http://www.wxpython.org/" target="_blank" rel="external">wxPython</a>、<a href="http://www.twistedmatrix.com/products/twisted" target="_blank" rel="external">Twisted</a>和<a href="http://www.pythonware.com/products/pil/index.htm" target="_blank" rel="external">Python图像库</a>等等。</p>
<h3 id="概括">概括</h3><p>Python确实是一种十分精彩又强大的语言。它合理地结合了高性能与使得编写程序简单有趣的特色。</p>
<h2 id="为什么不使用Perl？">为什么不使用Perl？</h2><p>也许你以前并不知道，Perl是另外一种极其流行的开源解释性编程语言。</p>
<p>如果你曾经尝试过用Perl语言编写一个大程序，你一定会自己回答这个问题。在规模较小的时候，Perl程序是简单的。它可以胜任于小型的应用程序和脚本，“使工作完成”。然而，当你想开始写一些大一点的程序的时候，Perl程序就变得不实用了。我是通过为Yahoo编写大型Perl程序的经验得出这样的总结的！</p>
<p>与Perl相比，Python程序一定会更简单、更清晰、更易于编写，从而也更加易懂、易维护。我确实也很喜欢Perl，用它来做一些日常的各种事情。不过当我要写一个程序的时候，我总是想到使用Python，这对我来说已经成了十分自然的事。Perl已经经历了多次大的修正和改变，遗憾的是，即将发布的Perl 6似乎仍然没有在这个方面做什么改进。</p>
<p>我感到Perl唯一也是十分重要的优势是它庞大的<a href="http://cpan.perl.org/" target="_blank" rel="external">CPAN</a>库——综合Perl存档网络。就如同这个名字所指的意思一样，这是一个巨大的Perl模块集，它大得让人难以置信——你几乎用这些模块在计算机上做任何事情。Perl的模块比Python多的原因之一是Perl拥有更加悠久的历史。或许我会在<a href="https://groups.google.com/groups?q=comp.lang.python" target="_blank" rel="external">comp.lang.python</a>上建议把Perl模块移植到Python上的计划。</p>
<p>另外，新的<a href="http://www.parrot.org/" target="_blank" rel="external">Parrot虚拟机</a>按设计可以运行完全重新设计的Perl 6也可以运行Python和其他解释性语言如Ruby、PHP和Tcl等等。这意味着你将来 或许 可以在Python上使用所有Perl的模块。这将成为两全其美的事——强大的CPAN库与强大的Python语言结合在一起。我们将拭目以待。</p>
<h2 id="程序员的话">程序员的话</h2><p>读一下像ESR这样的超级电脑高手谈Python的话，你会感到十分有意思：</p>
<blockquote>
<p><strong>Eric S. Raymond</strong>是《The Cathedral and the Bazaar》的作者、“开放源码”一词的提出人。他说<a href="http://www.linuxjournal.com/article/3882" target="_blank" rel="external">Python已经成为了他最喜爱的编程语言</a>。这篇文章也是促使我第一次接触Python的真正原动力。</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Bruce Eckel</strong>著名的《Thinking in Java》和《Thinking in C++》的作者。他说没有一种语言比得上Python使他的工作效率如此之高。同时他说Python可能是唯一一种旨在帮助程序员把事情弄得更加简单的语言。请阅读<a href="http://www.artima.com/inv/aboutme.html" target="_blank" rel="external">完整的采访</a>以获得更详细的内容。</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Peter Norvig</strong>是著名的Lisp语言书籍的作者和Google公司的搜索质量主任（感谢Guido van Rossum告诉我这一点）。他说Python始终是Google的主要部分。事实上你看一下<a href="http://www.google.com/about/jobs/" target="_blank" rel="external">Google招聘</a>的网页就可以验证这一点。在那个网页上，Python知识是对软件工程师的一个必需要求。</p>
</blockquote>
<!-- -->
<blockquote>
<p><strong>Bruce Perens</strong>是OpenSource.org和UserLinux项目的一位共同创始人。UserLinux旨在创造一个可以被多家发行商支持标准的Linux发行版。Python击败了其它竞争对手如Perl和Ruby成为UserLinux支持的主要编程语言。</p>
</blockquote>
<h1 id="安装Python">安装Python</h1><h2 id="Linux和BSD用户">Linux和BSD用户</h2><p>如果你正在使用一个Linux的发行版比如Fedora或者Mandrake或者其他（你的选择），或者一个BSD系统比如FreeBSD，那么你可能已经在你的系统里安装了Python。</p>
<p>要测试你是否已经随着你的Linux包安装了Python，你可以打开一个shell程序（就像konsole或gnome-terminal）然后输入如下所示的命令 <strong>python -V</strong> 。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python -<span class="constant">V</span></span><br><span class="line"><span class="constant">Python </span><span class="number">2.3</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注释:</strong></p>
<p>$是shell的提示符。根据你的操作系统的设置，它可能与你那个不同，因此我只用$符号表示提示符。</p>
</blockquote>
<p>如果你看见向上面所示的那样一些版本信息，那么你已经安装了Python了。</p>
<p>如果你得到像这样的消息：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python -<span class="constant">V</span></span><br><span class="line"><span class="symbol">bash:</span> <span class="symbol">python:</span> command <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>
<p>那么你还没有安装Python。这几乎不可能，只是极其偶尔才会遇到。</p>
<p>在这种情况下，你有两种方法在你的系统上安装Python。</p>
<ul>
<li><p>利用你的操作系统附带的包管理软件安装二进制包，比如Fedora Linux的yum、Mandrake Linux的urpmi、Debian Linux的apt-get、FreeBSD的pkg_add等等。注意，使用这种方法的话，你需要连接因特网。</p>
</li>
<li><p>你也可以从别的地方下载二进制包然后拷贝到你的PC中安装。</p>
</li>
<li><p>你可以从源代码编译<a href="http://www.python.org/download/" target="_blank" rel="external">Python</a>然后安装。在网站上有编译的指令。</p>
</li>
</ul>
<h2 id="Windows®用户">Windows®用户</h2><p>Windows®用户可以访问Python.org/download，从网站上下载最新的版本（在写本书的时候，最新版本是2.3.4版）。它的大小大约是9.4MB，与其他大多数语言相比是十分紧凑的。安装过程与其他Windows软件类似。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>即便安装程序为你提供了不检查 可选 组件的选项，你也不要不作任何检查！有些组件对你很有用，特别是集成开发环境。</p>
</blockquote>
<p>有趣的是，大约70%的Python下载是来自Windows用户的。当然，这并不能说明问题，因为几乎所有的Linux用户已经在安装系统的时候默认安装了Python。</p>
<blockquote>
<p><strong>在Windows命令行中使用Python</strong></p>
<p>如果你想要从Windows命令行调用Python，那么你需要先正确的设置PATH变量。</p>
<p>对于Windows 2000、XP、2003，点击控制面板-&gt;系统-&gt;高级-&gt;环境变量。在“系统变量”表单中点击叫做 <strong>PATH</strong> 的变量，然后编辑这个变量，把; <strong>C:\Python23</strong> 加到它的结尾。当然，是Python所在的正确目录名。</p>
<p>对于较旧版本的Windows，把下面这行加到文件C:\AUTOEXEC.BAT中： <strong>PATH=%PATH%;C:\Python23</strong> ，然后重新启动系统。对于Windows NT，则使用AUTOEXEC.NT文件。</p>
</blockquote>
<h2 id="概括-1">概括</h2><p>对于Linux系统，很可能你已经在你的系统里安装了Python。否则，你可以通过你的发行版附带的包管理软件安装Python。对于Windows系统，安装Python就是下载安装程序然后双击它那么简单。从现在起，我们将假设你已经在你的系统里安装了Python。</p>
<h1 id="最初的步骤">最初的步骤</h1><h2 id="简介-1">简介</h2><p>我们将看一下如何用Python编写运行一个传统的 <code>Hello World</code> 程序。通过它，你将学会如何编写、保存和运行Python程序。</p>
<p>有两种使用Python运行你的程序的方式——使用交互式的带提示符的解释器或使用源文件。我们将学习这两种方法。</p>
<h2 id="使用带提示符的解释器">使用带提示符的解释器</h2><p>在命令行的shell提示符下键入 <strong>python</strong> ，启动解释器。现在输入 <code>print &#39;Hello World&#39;</code> ，然后按Enter键。你应该可以看到输出的单词Hello World。</p>
<p>对于Windows用户，只要你正确的设置了PATH变量，你应该可以从命令行启动解释器。或者你可以选择使用IDLE程序。IDLE是集成开发环境的缩写。点击开始-&gt;程序-&gt;Python 2.3-&gt;IDLE(Python GUI)。Linux用户也可以使用IDLE。</p>
<p>注意， <code>&gt;&gt;&gt;</code> 是你键入Python语句的提示符。</p>
<p><strong>例3.1 使用带提示符的Python解释器</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">Python <span class="number">2.3</span>.4 (<span class="comment">#1, Oct 26 2004, 16:42:40)</span></span><br><span class="line">[GCC <span class="number">3.4</span>.2 <span class="number">20041017</span> (Red Hat <span class="number">3.4</span>.2-<span class="number">6.</span>fc3)] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'hello world'</span></span><br><span class="line">hello world</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>注意，Python会在下一行立即给出你输出！你刚才键入的是一句Python 语句 。我们使用 <code>print</code> （不要惊讶）来打印你提供给它的值。这里，我们提供的是文本Hello World，它被迅速地打印在屏幕上。</p>
<blockquote>
<p><strong>如何退出Python提示符</strong></p>
<p>如果你使用的是Linux/BSD shell，那么按Ctrl-d退出提示符。如果是在Windows命令行中，则按Ctrl-z再按Enter。</p>
</blockquote>
<h2 id="挑选一个编辑器">挑选一个编辑器</h2><p>在我们开始讲述以源文件方式编写Python程序之前，我们需要一个编辑器来写源文件。挑选一个编辑器确实是极其重要的。你挑选一个编辑器就如同你挑选一辆你将购买的轿车一样。一个好的编辑器会帮助你方便地编写Python程序，使你地编程旅程更加舒适，帮助你更加快捷安全地到达目的地（实现目标）。</p>
<p>对于编辑器的基本要求之一是 <strong>语法加亮</strong> 功能，利用这一功能，你的Python程序的不同部分被标以不同的颜色，这样你可以更好 <strong>看清楚</strong> 你的程序，使它的运行显得形象化。</p>
<p>如果你使用Windows，那么我建议你使用IDLE。IDLE具备语法加亮功能，还有许多其他的功能，比如允许你在IDLE中运行你的程序。特别值得注意的是： <strong>不要使用Notepad</strong> ——它是一个糟糕的选择，因为它没有语法加亮功能，而且更加重要的是，它不支持文本缩进。而我们将会看到文本缩进对于我们来说极其重要。一个好的编辑器，比如IDLE（还有VIM）将会自动帮助你做这些事情。</p>
<p>如果你使用Linux/FreeBSD，那么你有很多种选择。如果你是一位有经验的程序员，你一定已经在使用VIM或者Emacs了。勿庸置疑，它们是两个功能最强大的编辑器。使用它们编写你的Python程序，你将从中受益。我个人使用VIM编写我的大多数程序。如果你是一个初学编程的人，那么你可以使用Kate，它也是我最喜欢的编辑器之一。只要你愿意花时间学习使用VIM或Emacs，那么我强烈建议你一定要学习两者之一，因为从长远看来它们对你是极其有帮助的。</p>
<p>如果你还想寻找一下其他可供选择的编辑器，可以看一下详尽的<a href="http://wiki.python.org/moin/PythonEditors" target="_blank" rel="external">Python编辑器列表</a>，然后作出你的选择。你也可以使用Python的IDE（集成开发环境）。请看一下详尽的<a href="http://wiki.python.org/moin/IntegratedDevelopmentEnvironments" target="_blank" rel="external">支持Python的IDE列表</a>以获得详尽的信息。一旦你开始编写大型的Python程序，IDE确实很有用。</p>
<p>我再一次重申，请选择一个合适的编辑器——它能使编写Python程序变得更加有趣、方便。</p>
<h2 id="使用源文件">使用源文件</h2><p>现在让我们重新开始编程。当你学习一种新的编程语言的时候，你编写运行的第一个程序通常都是“Hello World”程序，这已经成为一种传统了。在你运行“Hello World”程序的时候，它所做的事只是说声：“Hello World”。正如提出“Hello World”程序的Simon Cozens[1]所说：</p>
<blockquote>
<p>它是编程之神的传统咒语，可以帮助你更好的学习语言。”</p>
</blockquote>
<p>启动你选择的编辑器，输入下面这段程序，然后把它保存为helloworld.py。</p>
<p><strong>例3.2 使用源文件</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename : helloworld.py</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure>
<p>(源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/helloworld.py" target="_blank" rel="external">code/helloworld.py</a>)</p>
<p>为了运行这个程序，请打开shell（Linux终端或者DOS提示符），然后键入命令 <code>python helloworld.py</code> 。如果你使用IDLE，请使用菜单Edit-&gt;Run Script或者使用键盘快捷方式 <code>Ctrl-F5</code> 。输出如下所示。</p>
<h3 id="输出">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python helloworld<span class="class">.py</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>如果你得到的输出与上面所示的一样，那么恭喜！——你已经成功地运行了你的第一个Python程序。</p>
<p>万一你得到一个错误，那么请确保你键入的程序 准确无误 ，然后再运行一下程序。注意Python是大小写敏感的，即 <code>print</code> 与 <code>Print</code> 不一样——注意前一个是小写p而后一个是大写P。另外，确保在每一行的开始字符前没有空格或者制表符——我们将在后面讨论为什么这点是重要的。</p>
<h3 id="它如何工作">它如何工作</h3><p>让我们思考一下这个程序的前两行。它们被称作 <em>注释</em> ——任何在#符号右面的内容都是注释。注释主要作为提供给程序读者的笔记。</p>
<p>Python至少应当有第一行那样的特殊形式的注释。它被称作 组织行 ——源文件的头两个字符是#!，后面跟着一个程序。这行告诉你的Linux/Unix系统当你 执行 你的程序的时候，它应该运行哪个解释器。这会在下一节做详细解释。注意，你总是可以通过直接在命令行指定解释器，从而在任何平台上运行你的程序。就如同命令 <code>python helloworld.py</code> 一样。</p>
<blockquote>
<p><strong>重要</strong></p>
<p>在你的程序中合理地使用注释以解释一些重要的细节——这将有助于你的程序的读者轻松地理解程序在干什么。记住，这个读者可能就是6个月以后的你！</p>
</blockquote>
<p>跟在注释之后的是一句Python 语句 ——它只是打印文本“Hello World”。print实际上是一个操作符，而“Hello World”被称为一个字符串——别担心我们会在后面详细解释这些术语。</p>
<h2 id="可执行的Python程序">可执行的Python程序</h2><p>这部分内容只对Linux/Unix用户适用，不过Windows用户可能也对程序的第一行比较好奇。首先我们需要通过 <code>chmod</code> 命令，给程序可执行的许可，然后 <em>运行</em> 程序。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ chmod a+x helloworld<span class="class">.py</span></span><br><span class="line">$ ./helloworld<span class="class">.py</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<p>chmod命令用来 <em>改变</em> 文件的 <em>模式</em> ，给系统中所有用户这个源文件的执行许可。然后我们可以直接通过指定源文件的位置来执行程序。我们使用./来指示程序位于当前目录。</p>
<p>为了更加有趣一些，你可以把你的文件名改成仅仅helloworld，然后运行.<strong>/helloworld</strong>。这样，这个程序仍然可以工作，因为系统知道它必须用源文件第一行指定的那个解释器来运行程序。</p>
<p>只要知道程序的确切位置，你现在就可以运行程序了——但是如果你希望你的程序能够从各个位置运行呢？那样的话，你可以把你的程序保存在PATH环境变量中的目录之一。每当你运行任何程序，系统会查找列在PATH环境变量中的各个目录。然后运行那个程序。你只要简单地把这个源文件复制到PATH所列目录之一就可以使你的程序在任何位置都可用了。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>echo <span class="variable">$PATH</span></span><br><span class="line">/opt/mono/bin/<span class="symbol">:/usr/local/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/bin</span><span class="symbol">:/usr/X11R6/bin</span><span class="symbol">:/home/swaroop/bin</span></span><br><span class="line"><span class="variable">$ </span>cp helloworld.py /home/swaroop/bin/helloworld</span><br><span class="line"><span class="variable">$ </span>helloworld</span><br><span class="line"><span class="constant">Hello World</span></span><br></pre></td></tr></table></figure>
<p>我们能够用 <strong>echo</strong> 命令来显示PATH变量，用$给变量名加前缀以向shell表示我们需要这个变量的值。我们看到/home/swaroop/bin是PATH变量中的目录之一。 <strong>swaroop</strong> 是我的系统中使用的用户名。通常，在你的系统中也会有一个相似的目录。你也可以把你选择的目录添加到PATH变量中去——这可以通过运行 <strong>PATH=$PATH:/home/swaroop/mydir</strong> 完成，其中“/home/swaroop/mydir”是我想要添加到PATH变量中的目录。</p>
<p>当你想要在任何时间、任何地方运行你的程序的时候，这个方法十分有用。它就好像创造你自己的指令，如同 <strong>cd</strong> 或其他Linux终端或DOS提示符命令那样。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>对于Python来说，程序、脚本或者软件都是指同一个东西。</p>
</blockquote>
<h2 id="获取帮助">获取帮助</h2><p>如果你需要某个Python函数或语句的快速信息帮助，那么你可以使用内建的help功能。尤其在你使用带提示符的命令行的时候，它十分有用。比如，运行 <code>help(str)</code> ——这会显示str类的帮助。str类用于保存你的程序使用的各种文本（字符串）。类将在后面面向对象编程的章节详细解释。</p>
<blockquote>
<p><strong>注释</strong></p>
<p>按q退出帮助。</p>
</blockquote>
<p>类似地，你可以获取Python中几乎所有东西的信息。使用help()去学习更多关于help本身的东西！</p>
<p>如果你想要获取关于如print那样操作符的帮助，那么你需要正确的设置PYTHONDOCS环境变量。这可以在Linux/Unix中轻松地通过 <strong>env</strong> 命令完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ env PYTHONDOCS=/usr/share/doc/python-docs-<span class="number">2.3</span>.4/html/ python</span><br><span class="line">Python <span class="number">2.3</span>.4 (<span class="comment">#1, Oct 26 2004, 16:42:40)</span></span><br><span class="line">[GCC <span class="number">3.4</span>.2 <span class="number">20041017</span> (Red Hat <span class="number">3.4</span>.2-<span class="number">6.</span>fc3)] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>help(<span class="string">'print'</span>)</span><br></pre></td></tr></table></figure>
<p>你应该注意到我特意在 <code>print</code> 上使用了引号，那样Python就可以理解我是希望获取关于 <code>print</code> 的帮助而不是想要它打印东西。</p>
<p>注意，我使用的位置是在Fedora Core 3 Linux中的位置——它可能在不同的发行版和版本中有所不同。</p>
<h2 id="概括-2">概括</h2><p>你现在应该可以方便地编写、保存和运行Python程序了。既然你是一个Python用户，让我们学习更多Python的概念。</p>
<hr>
<p>[1]一位最主要的Perl6/Parrot高手，轰动的《开始Perl》一书的作者。</p>
<h1 id="基本概念">基本概念</h1><p>仅仅打印 <code>Hello World</code> 就足够了吗？你应该想要做更多的事——你想要得到一些输入，然后做操作，再从中得到一些输出。在Python中，我们可以使用常量和变量来完成这些工作。</p>
<h2 id="字面意义上的常量">字面意义上的常量</h2><p>一个字面意义上的常量的例子是如同5、1.23、9.25e-3这样的数，或者如同’This is a string’、”It’s a string!”这样的字符串。它们被称作字面意义上的，因为它们具备 字面 的意义——你按照它们的字面意义使用它们的值。数2总是代表它自己，而不会是别的什么东西——它是一个常量，因为不能改变它的值。因此，所有这些都被称为字面意义上的常量。</p>
<h2 id="数">数</h2><p>在Python中有4种类型的数——整数、长整数、浮点数和复数。</p>
<ul>
<li>2是一个整数的例子。</li>
<li>长整数不过是大一些的整数。</li>
<li>3.23和52.3E-4是浮点数的例子。E标记表示10的幂。在这里，52.3E-4表示52.3 * 10-4。</li>
<li>(-5+4j)和(2.3-4.6j)是复数的例子。</li>
</ul>
<h2 id="字符串">字符串</h2><p>字符串是 <strong>字符的序列</strong> 。字符串基本上就是一组单词。</p>
<p>我几乎可以保证你在每个Python程序中都要用到字符串，所以请特别留心下面这部分的内容。下面告诉你如何在Python中使用字符串。</p>
<ul>
<li><p><strong>使用单引号（’）</strong></p>
<p>你可以用单引号指示字符串，就如同’Quote me on this’这样。所有的空白，即空格和制表符都照原样保留。</p>
</li>
<li><p><strong>使用双引号（”）</strong></p>
<p>在双引号中的字符串与单引号中的字符串的使用完全相同，例如”What’s your name?”。</p>
</li>
<li><p><strong>使用三引号（’’’或”””）</strong><br>利用三引号，你可以指示一个多行的字符串。你可以在三引号中自由的使用单引号和双引号。例如：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''This is a multi-line string. This is the first line.</span><br><span class="line">This is the second line.</span><br><span class="line">"What's your name?," I asked.</span><br><span class="line">He said "Bond, James Bond."</span><br><span class="line">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>转义符</strong><br>假设你想要在一个字符串中包含一个单引号（’），那么你该怎么指示这个字符串？例如，这个字符串是What’s your name?。你肯定不会用’What’s your name?’来指示它，因为Python会弄不明白这个字符串从何处开始，何处结束。所以，你需要指明单引号而不是字符串的结尾。可以通过 <em>转义符</em> 来完成这个任务。你用\’来指示单引号——注意这个反斜杠。现在你可以把字符串表示为’What\’s your name?’。</p>
<p>另一个表示这个特别的字符串的方法是”What’s your name?”，即用双引号。类似地，要在双引号字符串中使用双引号本身的时候，也可以借助于转义符。另外，你可以用转义符\\来指示反斜杠本身。</p>
<p>值得注意的一件事是，在一个字符串中，行末的单独一个反斜杠表示字符串在下一行继续，而不是开始一个新的行。例如：</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">"This is the first sentence.\</span><br><span class="line">This is the second sentence."</span></span><br></pre></td></tr></table></figure>
<p>等价于”This is the first sentence. This is the second sentence.”</p>
</li>
<li><strong>自然字符串</strong><br>如果你想要指示某些不需要如转义符那样的特别处理的字符串，那么你需要指定一个自然字符串。自然字符串通过给字符串加上前缀r或R来指定。例如r”Newlines are indicated by \n”。</li>
<li><p><strong>Unicode字符串</strong><br>Unicode是书写国际文本的标准方法。如果你想要用你的母语如北印度语或阿拉伯语写文本，那么你需要有一个支持Unicode的编辑器。类似地，Python允许你处理Unicode文本——你只需要在字符串前加上前缀u或U。例如，u”This is a Unicode string.”。</p>
<p>记住，在你处理文本文件的时候使用Unicode字符串，特别是当你知道这个文件含有用非英语的语言写的文本。</p>
</li>
<li><strong>字符串是不可变的</strong><br>这意味着一旦你创造了一个字符串，你就不能再改变它了。虽然这看起来像是一件坏事，但实际上它不是。我们将会在后面的程序中看到为什么我们说它不是一个缺点。</li>
<li><p><strong>按字面意义级连字符串</strong><br>如果你把两个字符串按字面意义相邻放着，他们会被Python自动级连。例如，’What\’s’ ‘your name?’会被自动转为”What’s your name?”。 </p>
<blockquote>
<p><strong>给C/C++程序员的注释</strong></p>
<p>在Python中没有专门的char数据类型。确实没有需要有这个类型，我相信你不会为此而烦恼。</p>
<p><strong>给Perl/PHP程序员的注释</strong></p>
<p>记住，单引号和双引号字符串是完全相同的——它们没有在任何方面有不同。</p>
<p><strong>给正则表达式用户的注释</strong></p>
<p>一定要用自然字符串处理正则表达式。否则会需要使用很多的反斜杠。例如，后向引用符可以写成’\\1’或r’\1’。</p>
</blockquote>
</li>
</ul>
<h2 id="变量">变量</h2><p>仅仅使用字面意义上的常量很快就会引发烦恼——我们需要一种既可以储存信息 又可以对它们进行操作的方法。这是为什么要引入 <em>变量</em> 。变量就是我们想要的东西——它们的值可以变化，即你可以使用变量存储任何东西。变量只是你的计算机中存储信息的一部分内存。与字面意义上的常量不同，你需要一些能够访问这些变量的方法，因此你给变量名字。</p>
<h2 id="标识符的命名">标识符的命名</h2><p>变量是标识符的例子。 <em>标识符</em> 是用来标识 <em>某样东西</em> 的名字。在命名标识符的时候，你要遵循这些规则：   </p>
<ul>
<li><p>标识符的第一个字符必须是字母表中的字母（大写或小写）或者一个下划线（‘ _ ’）。</p>
</li>
<li><p>标识符名称的其他部分可以由字母（大写或小写）、下划线（‘ _ ’）或数字（0-9）组成。</p>
</li>
<li><p>标识符名称是对大小写敏感的。例如，myname和myName <strong>不是</strong> 一个标识符。注意前者中的小写n和后者中的大写N。</p>
</li>
<li><p>有效 标识符名称的例子有i、__my_name、name_23和a1b2_c3。</p>
</li>
<li><p>无效 标识符名称的例子有2things、this is spaced out和my-name。</p>
</li>
</ul>
<h2 id="数据类型">数据类型</h2><p>变量可以处理不同类型的值，称为 <strong>数据类型</strong> 。基本的类型是数和字符串，我们已经讨论过它们了。在后面的章节里面，我们会研究怎么用类创造我们自己的类型。</p>
<h2 id="对象">对象</h2><p>记住，Python把在程序中用到的任何东西都称为 对象 。这是从广义上说的。因此我们不会说“某某 东西 ”，我们说“某个 对象 ”。</p>
<blockquote>
<p><strong>给面向对象编程用户的注释</strong></p>
<p>就每一个东西包括数、字符串甚至函数都是对象这一点来说，Python是极其完全地面向对象的。</p>
</blockquote>
<p>我们将看一下如何使用变量和字面意义上的常量。保存下面这个例子，然后运行程序。</p>
<blockquote>
<p><strong>如何编写Python程序</strong></p>
<p>下面是保存和运行Python程序的标准流程。</p>
<ol>
<li>打开你最喜欢的编辑器。</li>
<li>输入例子中的程序代码。</li>
<li>用注释中给出的文件名把它保存为一个文件。我按照惯例把所有的Python程序都以扩展名.py保存。</li>
<li>运行解释器命令 <strong>python program.py</strong> 或者使用IDLE运行程序。你也可以使用先前介绍的可执行的方法。 </li>
</ol>
</blockquote>
<p><strong>例4.1 使用变量和字面意义上的常量</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filename : var.py</span></span><br><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> i</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line">s = <span class="string">'''This is a multi-line string.</span><br><span class="line">This is the second line.'''</span></span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/expression.py" target="_blank" rel="external">code/var.py</a>）</p>
<h3 id="输出-1">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> var.<span class="keyword">py</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">a</span> multi-<span class="built_in">line</span> <span class="built_in">string</span>.</span><br><span class="line">This <span class="keyword">is</span> the second <span class="built_in">line</span>.</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-1">它如何工作</h3><p>下面来说明一下这个程序如何工作。首先我们使用赋值运算符（=）把一个字面意义上的常数5赋给变量i。这一行称为一个语句。语句声明需要做某件事情，在这个地方我们把变量名i与值5连接在一起。接下来，我们用print语句打印i的值，就是把变量的值打印在屏幕上。</p>
<p>然后我们对i中存储的值加1，再把它存回i。我们打印它时，得到期望的值6。</p>
<p>类似地，我们把一个字面意义上的字符串赋给变量s然后打印它。</p>
<blockquote>
<p><strong>给C/C++程序员的注释</strong> </p>
<p>使用变量时只需要给它们赋一个值。不需要声明或定义数据类型。</p>
</blockquote>
<h2 id="逻辑行与物理行">逻辑行与物理行</h2><p>物理行是你在编写程序时所 看见 的。逻辑行是Python 看见 的单个语句。Python假定每个 物理行 对应一个 逻辑行 。</p>
<p>逻辑行的例子如 <code>print &#39;Hello World&#39;</code> 这样的语句——如果它本身就是一行（就像你在编辑器中看到的那样），那么它也是一个物理行。</p>
<p>默认地，Python希望每行都只使用一个语句，这样使得代码更加易读。</p>
<p>如果你想要在一个物理行中使用多于一个逻辑行，那么你需要使用分号（;）来特别地标明这种用法。分号表示一个逻辑行/语句的结束。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<p>与下面这个相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">print</span> i;</span><br></pre></td></tr></table></figure>
<p>同样也可以写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span>; <span class="keyword">print</span> i;</span><br></pre></td></tr></table></figure>
<p>甚至可以写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span>; <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<p>然而，我 <strong>强烈建议</strong> 你坚持 <strong>在每个物理行只写一句逻辑行</strong> 。仅仅当逻辑行太长的时候，在多于一个物理行写一个逻辑行。这些都是为了尽可能避免使用分号，从而让代码更加易读。事实上，我 从来没有 在Python程序中使用过或看到过分号。</p>
<p>下面是一个在多个物理行中写一个逻辑行的例子。它被称为 <strong>明确的行连接</strong> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'This is a string. \</span><br><span class="line">This continues the string.'</span></span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure>
<p>它的输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is <span class="operator">a</span> <span class="keyword">string</span>. This continues <span class="operator">the</span> <span class="keyword">string</span>.</span><br></pre></td></tr></table></figure>
<p>类似地，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> \</span><br><span class="line">i</span><br></pre></td></tr></table></figure>
<p>与如下写法效果相同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> i</span><br></pre></td></tr></table></figure>
<p>有时候，有一种暗示的假设，可以使你不需要使用反斜杠。这种情况出现在逻辑行中使用了圆括号、方括号或波形括号的时候。这被称为 <strong>暗示的行连接</strong> 。你会在后面介绍如何使用列表的章节中看到这种用法</p>
<h2 id="缩进">缩进</h2><p>空白在Python中是重要的。事实上 <strong>行首的空白是重要的</strong>  。它称为 <strong>缩进</strong>  。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。</p>
<p>这意味着同一层次的语句 <strong>必须</strong> 有相同的缩进。每一组这样的语句称为一个 <strong>块</strong>  。我们将在后面的章节中看到有关块的用处的例子。</p>
<p>你需要记住的一样东西是错误的缩进会引发错误。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span></span><br><span class="line"> <span class="keyword">print</span> <span class="string">'Value is'</span>, i <span class="comment"># Error! Notice a single space at the start of the line</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'I repeat, the value is'</span>, i</span><br></pre></td></tr></table></figure>
<p>当你运行这个程序的时候，你会得到下面的错误：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="title">File</span> <span class="string">"whitespace.py"</span>, line <span class="number">4</span></span><br><span class="line">    print <span class="string">'Value is'</span>, i <span class="comment"># Error! Notice a single space at the start of the line</span></span><br><span class="line">   <span class="regexp"> ^</span></span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<p>注意，在第二行的行首有一个空格。Python指示的这个错误告诉我们程序的语法是无效的，即程序没有正确地编写。它告诉你， 你不能随意地开始新的语句块 （当然除了你一直在使用的主块）。何时你能够使用新块，将会在后面的章节，如控制流中详细介绍。</p>
<blockquote>
<p><strong>如何缩进</strong></p>
<p>不要混合使用制表符和空格来缩进，因为这在跨越不同的平台的时候，无法正常工作。我 强烈建议 你在每个缩进层次使用 单个制表符 或 两个或四个空格 。<br>选择这三种缩进风格之一。更加重要的是，选择一种风格，然后 <strong>一贯地</strong> 使用它，即 只 使用这一种风格。</p>
</blockquote>
<h2 id="概括-3">概括</h2><p>现在我们已经学习了很多详细的内容，我们可以开始学习更加令你感兴趣的东西，比如控制流语句。在继续学习之前，请确信你对本章的内容清楚明了。</p>
<h1 id="运算符与表达式">运算符与表达式</h1><h2 id="简介-2">简介</h2><p>你编写的大多数语句（逻辑行）都包含 <strong>表达式</strong>  。一个简单的表达式例子如2 + 3。一个表达式可以分解为运算符和操作数。</p>
<p>运算符 的功能是完成某件事，它们由如+这样的符号或者其他特定的关键字表示。运算符需要数据来进行运算，这样的数据被称为 操作数 。在这个例子中，2和3是操作数。</p>
<h2 id="运算符">运算符</h2><p>我们将简单浏览一下运算符和它们的用法：</p>
<h3 id="技巧">技巧</h3><p>你可以交互地使用解释器来计算例子中给出的表达式。例如，为了测试表达式2 + 3，使用交互式的带提示符的Python解释器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">5</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>表5.1 运算符与它们的用法</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加</td>
<td>两个对象相加</td>
<td>3 + 5得到8。’a’ + ‘b’得到’ab’ </td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>得到负数或是一个数减去另一个数</td>
<td>-5.2得到一个负数。50 - 24得到26。</td>
</tr>
<tr>
<td>*</td>
<td>幂</td>
<td>返回x的y次幂</td>
<td>3 <em>* 4得到81（即3 </em> 3 <em> 3 </em> 3）</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>x除以y</td>
<td>4/3得到1（整数的除法得到整数结果）。4.0/3或4/3.0得到1.3333333333333333</td>
</tr>
<tr>
<td>//</td>
<td>取整除</td>
<td>返回商的整数部分</td>
<td>4 // 3.0得到1.0</td>
</tr>
<tr>
<td>%</td>
<td>取模</td>
<td>返回除法的余数</td>
<td>8%3得到2。-25.5%2.25得到1.5</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>把一个数的比特向左移一定数目（每个数在内存中都表示为比特或二进制数字，即0和1）</td>
<td>2 &lt;&lt; 2得到8。——2按比特表示为10 </td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>把一个数的比特向右移一定数目</td>
<td>11 &gt;&gt; 1得到5。——11按比特表示为1011，向右移动1比特后得到101，即十进制的5。</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>数的按位与</td>
<td>5 &amp; 3得到1。</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>按位或</td>
<td>数的按位或</td>
<td>5</td>
<td>3得到7。</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>数的按位异或</td>
<td>5 ^ 3得到6</td>
</tr>
<tr>
<td>~</td>
<td>按位翻转</td>
<td>x的按位翻转是-(x+1)</td>
<td>~5得到6。</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td>
<td>5 &lt; 3返回0（即False）而3 &lt; 5返回1（即True）。比较可以被任意连接：3 &lt; 5 &lt; 7返回True。</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>返回x是否大于y</td>
<td>5 &gt; 3返回True。如果两个操作数都是数字，它们首先被转换为一个共同的类型。否则，它总是返回False。</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>返回x是否小于等于y</td>
<td>x = 3; y = 6; x &lt;= y返回True。</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>返回x是否大于等于y</td>
<td>x = 4; y = 3; x &gt;= y返回True。</td>
</tr>
<tr>
<td>==</td>
<td>等于</td>
<td>比较对象是否相等</td>
<td>x = 2; y = 2; x == y返回True。x = ‘str’; y = ‘stR’; x == y返回False。x = ‘str’; y = ‘str’; x == y返回True。</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>比较两个对象是否不相等</td>
<td>x = 2; y = 3; x != y返回True。</td>
</tr>
<tr>
<td>not</td>
<td>布尔“非”</td>
<td>如果x为True，返回False。如果x为False，它返回True。</td>
<td>x = True; not y返回False。</td>
</tr>
<tr>
<td>and</td>
<td>布尔“与”</td>
<td>如果x为False，x and y返回False，否则它返回y的计算值。</td>
<td>x = False; y = True; x and y，由于x是False，返回False。在这里，Python不会计算y，因为它知道这个表达式的值肯定是False（因为x是False）。这个现象称为短路计算。</td>
</tr>
<tr>
<td>or</td>
<td>布尔“或”</td>
<td>如果x是True，它返回True，否则它返回y的计算值。</td>
<td>x = True; y = False; x or y返回True。短路计算在这里也适用。</td>
</tr>
</tbody>
</table>
<h2 id="运算符优先级">运算符优先级</h2><p>如果你有一个如2 + 3 * 4那样的表达式，是先做加法呢，还是先做乘法？我们的中学数学告诉我们应当先做乘法——这意味着乘法运算符的优先级高于加法运算符。</p>
<p>下面这个表给出Python的运算符优先级，从最低的优先级（最松散地结合）到最高的优先级（最紧密地结合）。这意味着在一个表达式中，Python会首先计算表中较下面的运算符，然后在计算列在表上部的运算符。</p>
<p>下面这张表（与Python参考手册中的那个表一模一样）已经顾及了完整的需要。事实上，我建议你使用圆括号来分组运算符和操作数，以便能够明确地指出运算的先后顺序，使程序尽可能地易读。例如，2 + (3 <em> 4)显然比2 + 3 </em> 4清晰。与此同时，圆括号也应该正确使用，而不应该用得过滥（比如2 + (3 + 4)）。</p>
<p><strong>表5.2 运算符优先级</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>lambda</td>
<td>Lambda表达式</td>
</tr>
<tr>
<td>or</td>
<td>布尔“或”</td>
</tr>
<tr>
<td>and</td>
<td>布尔“与”</td>
</tr>
<tr>
<td>not x</td>
<td>布尔“非”</td>
</tr>
<tr>
<td>in，not in</td>
<td>成员测试</td>
</tr>
<tr>
<td>is，is not</td>
<td>同一性测试</td>
</tr>
<tr>
<td>&lt;，&lt;=，&gt;，&gt;=，!=，==</td>
<td>比较</td>
</tr>
<tr>
<td>`</td>
<td>`</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>&lt;&lt;，&gt;&gt;</td>
<td>移位</td>
</tr>
<tr>
<td>+，-</td>
<td>加法与减法</td>
</tr>
<tr>
<td>*，/，%</td>
<td>乘法、除法与取余</td>
</tr>
<tr>
<td>+x，-x</td>
<td>正负号</td>
</tr>
<tr>
<td>~x</td>
<td>按位翻转</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
</tr>
<tr>
<td>x.attribute</td>
<td>属性参考</td>
</tr>
<tr>
<td>x[index]</td>
<td>下标</td>
</tr>
<tr>
<td>x[index:index]</td>
<td>寻址段</td>
</tr>
<tr>
<td>f(arguments…)</td>
<td>函数调用</td>
</tr>
<tr>
<td>(experession,…)</td>
<td>绑定或元组显示</td>
</tr>
<tr>
<td>[expression,…]</td>
<td>列表显示</td>
</tr>
<tr>
<td>{key:datum,…}</td>
<td>字典显示</td>
</tr>
<tr>
<td>‘expression,…’</td>
<td>字符串转换</td>
</tr>
</tbody>
</table>
<p>其中我们还没有接触过的运算符将在后面的章节中介绍。</p>
<p>在表中列在同一行的运算符具有 相同优先级 。例如，+和-有相同的优先级。</p>
<h3 id="计算顺序">计算顺序</h3><p>默认地，运算符优先级表决定了哪个运算符在别的运算符之前计算。然而，如果你想要改变它们的计算顺序，你得使用圆括号。例如，你想要在一个表达式中让加法在乘法之前计算，那么你就得写成类似(2 + 3) * 4的样子。</p>
<h3 id="结合规律">结合规律</h3><p>运算符通常由左向右结合，即具有相同优先级的运算符按照从左向右的顺序计算。例如，2 + 3 + 4被计算成(2 + 3) + 4。一些如赋值运算符那样的运算符是由右向左结合的，即a = b = c被处理为a = (b = c)。</p>
<h2 id="表达式">表达式</h2><h3 id="使用表达式">使用表达式</h3><p><strong>例5.1 使用表达式</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: expression.py</span></span><br><span class="line"></span><br><span class="line">length = <span class="number">5</span></span><br><span class="line">breadth = <span class="number">2</span></span><br><span class="line">area = length * breadth</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Area is'</span>, area</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Perimeter is'</span>, <span class="number">2</span> * (length + breadth)</span><br></pre></td></tr></table></figure>
<p>（源文件： <a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/expression.py" target="_blank" rel="external">code/expression.py</a>）</p>
<h3 id="输出-2">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> expression.<span class="keyword">py</span></span><br><span class="line">Area <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line">Perimeter <span class="keyword">is</span> <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-2">它如何工作</h3><p>矩形的长度与宽度存储在以它们命名的变量中。我们借助表达式使用它们计算矩形的面积和边长。我们表达式length <em> breadth的结果存储在变量area中，然后用print语句打印。在另一个打印语句中，我们直接使用表达式2 </em> (length + breadth)的值。</p>
<p>另外，注意Python如何打印“漂亮的”输出。尽管我们没有在’Area is’和变量area之间指定空格，Python自动在那里放了一个空格，这样我们就可以得到一个清晰漂亮的输出，而程序也变得更加易读（因为我们不需要担心输出之间的空格问题）。这是Python如何使程序员的生活变得更加轻松的一个例子。</p>
<h2 id="概括-4">概括</h2><p>我们已经学习了如何使用运算符、操作数和表达式——这些使任何程序的基本组成部分。接下来，我们将学习如何通过语句在我们的程序中使用这些部分。</p>
<h1 id="控制流">控制流</h1><h2 id="简介-3">简介</h2><p>在到目前为止我们所见到的程序中，总是有一系列的语句，Python忠实地按照它们的顺序执行它们。如果你想要改变语句流的执行顺序，该怎么办呢？例如，你想要让程序做一些决定，根据不同的情况做不同的事情，例如根据时间打印“早上好”或者“晚上好”。</p>
<p>你可能已经猜到了，这是通过控制流语句实现的。在Python中有三种控制流语句——if、for和while。</p>
<h2 id="if语句">if语句</h2><p>if语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则 我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。</p>
<h3 id="使用if语句">使用if语句</h3><p><strong>例6.1 使用if语句</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: if.py </span></span><br><span class="line"></span><br><span class="line">number = <span class="number">23</span></span><br><span class="line">guess = int(raw_input(<span class="string">'Enter an integer : '</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> guess == number:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Congratulations, you guessed it.'</span> <span class="comment"># New block starts here</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"(but you do not win any prizes!)"</span> <span class="comment"># New block ends here</span></span><br><span class="line"><span class="keyword">elif</span> guess &lt; number:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'No, it is a little higher than that'</span> <span class="comment"># Another block</span></span><br><span class="line">    <span class="comment"># You can do whatever you want in a block ...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'No, it is a little lower than that'</span> </span><br><span class="line">    <span class="comment"># you must have guess &gt; number to reach here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Done'</span></span><br><span class="line"><span class="comment"># This last statement is always executed, after the if statement is executed</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/if.py" target="_blank" rel="external">code/if.py</a>）</p>
<h3 id="输出-3">输出</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">if</span>.py</span><br><span class="line">Enter <span class="operator">an</span> <span class="keyword">integer</span> : <span class="number">50</span></span><br><span class="line">No, <span class="keyword">it</span> is <span class="operator">a</span> little <span class="built_in">lower</span> than that</span><br><span class="line">Done</span><br><span class="line">$ python <span class="keyword">if</span>.py</span><br><span class="line">Enter <span class="operator">an</span> <span class="keyword">integer</span> : <span class="number">22</span></span><br><span class="line">No, <span class="keyword">it</span> is <span class="operator">a</span> little higher than that</span><br><span class="line">Done</span><br><span class="line">$ python <span class="keyword">if</span>.py</span><br><span class="line">Enter <span class="operator">an</span> <span class="keyword">integer</span> : <span class="number">23</span></span><br><span class="line">Congratulations, you guessed <span class="keyword">it</span>.</span><br><span class="line">(but you <span class="built_in">do</span> <span class="operator">not</span> win <span class="keyword">any</span> prizes!)</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-3">它如何工作</h3><p>在这个程序中，我们从用户处得到猜测的数，然后检验这个数是否是我们手中的那个。我们把变量number设置为我们想要的任何整数，在这个例子中是23。然后，我们使用raw_input()函数取得用户猜测的数字。函数只是重用的程序段。我们将在下一章学习更多关于函数的知识。</p>
<p>我们为内建的 <code>raw_input</code> 函数提供一个字符串，这个字符串被打印在屏幕上，然后等待用户的输入。一旦我们输入一些东西，然后按 <strong>回车</strong> 键之后，函数返回输入。对于raw_input函数来说是一个字符串。我们通过int把这个字符串转换为整数，并把它存储在变量guess中。事实上，int是一个类，不过你想在对它所需了解的只是它把一个字符串转换为一个整数（假设这个字符串含有一个有效的整数文本信息）。</p>
<p>接下来，我们将用户的猜测与我们选择的数做比较。如果他们相等，我们打印一个成功的消息。注意我们使用了缩进层次来告诉Python每个语句分别属于哪一个块。这就是为什么缩进在Python如此重要的原因。我希望你能够坚持“每个缩进层一个制表符”的规则。你是这样的吗？</p>
<p>注意if语句在结尾处包含一个冒号——我们通过它告诉Python下面跟着一个语句块。</p>
<p>然后，我们检验猜测是否小于我们的数，如果是这样的，我们告诉用户它的猜测大了一点。我们在这里使用的是elif从句，它事实上把两个相关联的if else-if else语句合并为一个if-elif-else语句。这使得程序更加简单，并且减少了所需的缩进数量。</p>
<p>elif和else从句都必须在逻辑行结尾处有一个冒号，下面跟着一个相应的语句块（当然还包括正确的缩进）。</p>
<p>你也可以在一个if块中使用另外一个if语句，等等——这被称为嵌套的if语句。</p>
<p>记住，elif和else部分是可选的。一个最简单的有效if语句是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, it is true'</span></span><br></pre></td></tr></table></figure>
<p>在Python执行完一个完整的if语句以及与它相关联的elif和else从句之后，它移向if语句块的下一个语句。在这个例子中，这个语句块是主块。程序从主块开始执行，而下一个语句是print ‘Done’语句。在这之后，Python看到程序的结尾，简单的结束运行。</p>
<p>尽管这是一个非常简单的程序，但是我已经在这个简单的程序中指出了许多你应该注意的地方。所有这些都是十分直接了当的（对于那些拥有C/C++背景的用户来说是尤为简单的）。它们在开始时会引起你的注意，但是以后你会对它们感到熟悉、“自然”。</p>
<blockquote>
<p><strong>给C/C++程序员的注释</strong> </p>
<p>在Python中没有switch语句。你可以使用if..elif..else语句来完成同样的工作（在某些场合，使用字典会更加快捷。）</p>
</blockquote>
<h2 id="while语句">while语句</h2><p>只要在一个条件为真的情况下，while语句允许你重复执行一块语句。while语句是所谓 循环 语句的一个例子。while语句有一个可选的else从句。</p>
<h3 id="使用while语句">使用while语句</h3><p><strong>例6.2 使用while语句</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: while.py</span></span><br><span class="line"></span><br><span class="line">number = <span class="number">23</span></span><br><span class="line">running = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> running:</span><br><span class="line">    guess = int(raw_input(<span class="string">'Enter an integer : '</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess == number:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Congratulations, you guessed it.'</span> </span><br><span class="line">        running = <span class="keyword">False</span> <span class="comment"># this causes the while loop to stop</span></span><br><span class="line">    <span class="keyword">elif</span> guess &lt; number:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'No, it is a little higher than that'</span> </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'No, it is a little lower than that'</span> </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'The while loop is over.'</span> </span><br><span class="line">    <span class="comment"># Do anything else you want to do here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Done'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/while.py" target="_blank" rel="external">code/while.py</a>)</p>
<h3 id="输出-4">输出</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">while</span>.py</span><br><span class="line">Enter an <span class="type">integer</span> : <span class="number">50</span></span><br><span class="line">No, <span class="keyword">it</span> <span class="keyword">is</span> a little lower than <span class="keyword">that</span>.</span><br><span class="line">Enter an <span class="type">integer</span> : <span class="number">22</span></span><br><span class="line">No, <span class="keyword">it</span> <span class="keyword">is</span> a little higher than <span class="keyword">that</span>.</span><br><span class="line">Enter an <span class="type">integer</span> : <span class="number">23</span></span><br><span class="line">Congratulations, you guessed <span class="keyword">it</span>.</span><br><span class="line">The <span class="keyword">while</span> loop <span class="keyword">is</span> <span class="keyword">over</span>.</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-4">它如何工作</h3><p>在这个程序中，我们仍然使用了猜数游戏作为例子，但是这个例子的优势在于用户可以不断的猜数，直到他猜对为止——这样就不需要像前面那个例子那样为每次猜测重复执行一遍程序。这个例子恰当地说明了while语句的使用。</p>
<p>我们把raw_input和if语句移到了while循环内，并且在while循环开始前把running变量设置为True。首先，我们检验变量running是否为True，然后执行后面的 while-块 。在执行了这块程序之后，再次检验条件，在这个例子中，条件是running变量。如果它是真的，我们再次执行while-块，否则，我们继续执行可选的else-块，并接着执行下一个语句。</p>
<p>当while循环条件变为False的时候，else块才被执行——这甚至也可能是在条件第一次被检验的时候。如果while循环有一个else从句，它将始终被执行，除非你的while循环将永远循环下去不会结束！</p>
<p>True和False被称为布尔类型。你可以分别把它们等效地理解为值1和0。在检验重要条件的时候，布尔类型十分重要，它们并不是真实的值1。</p>
<p>else块事实上是多余的，因为你可以把其中的语句放在同一块（与while相同）中，跟在while语句之后，这样可以取得相同的效果。</p>
<blockquote>
<p><strong>给C/C++程序员的注释</strong> </p>
<p>记住，你可以在while循环中使用一个else从句。</p>
</blockquote>
<h2 id="for循环">for循环</h2><p>for..in是另外一个循环语句，它在一序列的对象上 递归 即逐一使用队列中的每个项目。我们会在后面的章节中更加详细地学习序列。</p>
<h3 id="使用for语句">使用for语句</h3><p><strong>例6.3 使用for语句</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: for.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'The for loop is over'</span></span><br></pre></td></tr></table></figure>
<h3 id="输出-5">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> <span class="keyword">for</span>.<span class="keyword">py</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">The <span class="keyword">for</span> loop <span class="keyword">is</span> over</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-5">它如何工作</h3><p>在这个程序中，我们打印了一个 序列 的数。我们使用内建的range函数生成这个数的序列。</p>
<p>我们所做的只是提供两个数，range返回一个序列的数。这个序列从第一个数开始到第二个数为止。例如，range(1,5)给出序列[1, 2, 3, 4]。默认地，range的步长为1。如果我们为range提供第三个数，那么它将成为步长。例如，range(1,5,2)给出[1,3]。记住，range 向上 延伸到第二个数，即它 <strong>不</strong>  包含第二个数。</p>
<p>for循环在这个范围内递归——for i in range(1,5)等价于for i in [1, 2, 3, 4]，这就如同把序列中的每个数（或对象）赋值给i，一次一个，然后以每个i的值执行这个程序块。在这个例子中，我们只是打印i的值。</p>
<p>记住，else部分是可选的。如果包含else，它总是在for循环结束后执行一次，除非遇到break语句。</p>
<p>记住，for..in循环对于任何序列都适用。这里我们使用的是一个由内建range函数生成的数的列表，但是广义说来我们可以使用任何种类的由任何对象组成的序列！我们会在后面的章节中详细探索这个观点。</p>
<blockquote>
<p><strong>给C/C++/Java/C#程序员的注释</strong></p>
<p>Python的for循环从根本上不同于C/C++的for循环。C#程序员会注意到Python的for循环与C#中的foreach循环十分类似。Java程序员会注意到它与Java 1.5中的for (int i : IntArray)相似。<br>在C/C++中，如果你想要写for (int i = 0; i &lt; 5; i++)，那么用Python，你写成for i in range(0,5)。你会注意到，Python的for循环更加简单、明白、不易出错。</p>
</blockquote>
<h2 id="break语句">break语句</h2><p>break语句是用来 终止 循环语句的，即哪怕循环条件没有称为False或序列还没有被完全递归，也停止执行循环语句。</p>
<p>一个重要的注释是，如果你从for或while循环中 终止 ，任何对应的循环else块将 <strong>不</strong>  执行。</p>
<h3 id="使用break语句">使用break语句</h3><p><strong>例6.4 使用break语句</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: break.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    s = raw_input(<span class="string">'Enter something : '</span>)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">'quit'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Length of the string is'</span>, len(s)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Done'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/break.py" target="_blank" rel="external">code/break.py</a>）</p>
<h3 id="输出-6">输出</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">break</span>.py</span><br><span class="line">Enter something : Programming <span class="keyword">is</span> <span class="function"><span class="keyword">fun</span></span></span><br><span class="line">Length of the string <span class="keyword">is</span> <span class="number">18</span></span><br><span class="line">Enter something : When the work <span class="keyword">is</span> done</span><br><span class="line">Length of the string <span class="keyword">is</span> <span class="number">21</span></span><br><span class="line">Enter something : <span class="keyword">if</span> you wanna make your work also <span class="function"><span class="keyword">fun</span>:</span></span><br><span class="line">Length of the string <span class="keyword">is</span> <span class="number">37</span></span><br><span class="line">Enter something :       use Python!</span><br><span class="line">Length of the string <span class="keyword">is</span> <span class="number">12</span></span><br><span class="line">Enter something : quit</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-6">它如何工作</h3><p>在这个程序中，我们反复地取得用户地输入，然后打印每次输入地长度。我们提供了一个特别的条件来停止程序，即检验用户的输入是否是’quit’。通过 终止 循环到达程序结尾来停止程序。</p>
<p>输入字符串的长度通过内建的len函数取得。</p>
<p>记住，break语句也可以在for循环中使用。</p>
<h3 id="G2的Python诗">G2的Python诗</h3><p>我在这里输入的是我所写的一段小诗，称为 <strong>G2的Python诗</strong>  ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    Programming <span class="keyword">is</span> <span class="function"><span class="keyword">fun</span></span></span><br><span class="line">When the work <span class="keyword">is</span> done</span><br><span class="line"><span class="keyword">if</span> you wanna make your work also <span class="function"><span class="keyword">fun</span>:</span></span><br><span class="line">      use Python!</span><br></pre></td></tr></table></figure>
<h2 id="continue语句">continue语句</h2><p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后 继续 进行下一轮循环。</p>
<h3 id="使用continue语句">使用continue语句</h3><p><strong>例6.5 使用continue语句</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: continue.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    s = raw_input(<span class="string">'Enter something : '</span>)</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">'quit'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Input is of sufficient length'</span></span><br><span class="line">    <span class="comment"># Do other kinds of processing here...</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/continue.py" target="_blank" rel="external">code/continue.py</a>）</p>
<h3 id="输出-7">输出</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">continue</span>.py</span><br><span class="line">Enter <span class="string">something :</span> a</span><br><span class="line">Enter <span class="string">something :</span> <span class="number">12</span></span><br><span class="line">Enter <span class="string">something :</span> abc</span><br><span class="line">Input is of sufficient length</span><br><span class="line">Enter <span class="string">something :</span> quit</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-7">它如何工作</h3><p>在这个程序中，我们从用户处取得输入，但是我们仅仅当它们有至少3个字符长的时候才处理它们。所以，我们使用内建的len函数来取得长度。如果长度小于3，我们将使用continue语句忽略块中的剩余的语句。否则，这个循环中的剩余语句将被执行，我们可以在这里做我们希望的任何处理。</p>
<p>注意，continue语句对于for循环也有效。</p>
<h2 id="概括-5">概括</h2><p>我们已经学习了如何使用三种控制流语句—— <code>if</code> 、 <code>while</code> 和 <code>for</code> 以及与它们相关的 <code>break</code> 和 <code>continue</code> 语句。它们是Python中最常用的部分，熟悉这些控制流是应当掌握的基本技能。</p>
<p>接下来，我们将学习如何创建和使用函数。</p>
<h1 id="函数">函数</h1><h2 id="简介-4">简介</h2><p>函数是重用的程序段。它们允许你给一块语句一个名称，然后你可以在你的程序的任何地方使用这个名称任意多次地运行这个语句块。这被称为 调用 函数。我们已经使用了许多内建的函数，比如len和range。</p>
<p>函数通过def关键字 <strong>定义</strong>  。def关键字后跟一个函数的 标识符 名称，然后跟一对圆括号。圆括号之中可以包括一些变量名，该行以冒号结尾。接下来是一块语句，它们是函数体。下面这个例子将说明这事实上是十分简单的：</p>
<h3 id="定义函数">定义函数</h3><p><strong>例7.1 定义函数</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: function1.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Hello World!'</span> <span class="comment"># block belonging to the function</span></span><br><span class="line"></span><br><span class="line">sayHello() <span class="comment"># call the function</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/function1.py" target="_blank" rel="external">code/function1.py</a>)</p>
<h3 id="输出-8">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python function1<span class="class">.py</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-8">它如何工作</h3><p>我们使用上面解释的语法定义了一个称为sayHello的函数。这个函数不使用任何参数，因此在圆括号中没有声明任何变量。参数对于函数而言，只是给函数的输入，以便于我们可以传递不同的值给函数，然后得到相应的结果。</p>
<h2 id="函数形参">函数形参</h2><p>函数取得的参数是你提供给函数的值，这样函数就可以利用这些值 做 一些事情。这些参数就像变量一样，只不过它们的值是在我们调用函数的时候定义的，而非在函数本身内赋值。</p>
<p>参数在函数定义的圆括号对内指定，用逗号分割。当我们调用函数的时候，我们以同样的方式提供值。注意我们使用过的术语——函数中的参数名称为 形参 而你提供给函数调用的值称为 实参 。</p>
<h3 id="使用函数形参">使用函数形参</h3><p><strong>例7.2 使用函数形参</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: func_param.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printMax</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">        <span class="keyword">print</span> a, <span class="string">'is maximum'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> b, <span class="string">'is maximum'</span></span><br><span class="line"></span><br><span class="line">printMax(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># directly give literal values</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">printMax(x, y) <span class="comment"># give variables as arguments</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/func_param.py" target="_blank" rel="external">code/func_param.py</a>)</p>
<h3 id="输出-9">输出</h3><p>这里，我们定义了一个称为printMax的函数，这个函数需要两个形参，叫做a和b。我们使用if..else语句找出两者之中较大的一个数，并且打印较大的那个数。</p>
<p>在第一个printMax使用中，我们直接把数，即实参，提供给函数。在第二个使用中，我们使用变量调用函数。printMax(x, y)使实参x的值赋给形参a，实参y的值赋给形参b。在两次调用中，printMax函数的工作完全相同。</p>
<h2 id="局部变量">局部变量</h2><p>当你在函数定义内声明变量的时候，它们与函数外具有相同名称的其他变量没有任何关系，即变量名称对于函数来说是 局部 的。这称为变量的 作用域 。所有变量的作用域是它们被定义的块，从它们的名称被定义的那点开始。</p>
<h3 id="使用局部变量">使用局部变量</h3><p><strong>例7.3 使用局部变量</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: func_local.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'x is'</span>, x</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Changed local x to'</span>, x</span><br><span class="line"></span><br><span class="line">x = <span class="number">50</span></span><br><span class="line">func(x)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'x is still'</span>, x</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/func_local.py" target="_blank" rel="external">code/func_local.py</a>)</p>
<h3 id="输出-10">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> func_local.<span class="keyword">py</span></span><br><span class="line"><span class="keyword">x</span> <span class="keyword">is</span> <span class="number">50</span></span><br><span class="line">Changed local <span class="keyword">x</span> <span class="keyword">to</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">x</span> <span class="keyword">is</span> still <span class="number">50</span></span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-9">它如何工作</h3><p>在函数中，我们第一次使用x的 值 的时候，Python使用函数声明的形参的值。</p>
<p>接下来，我们把值2赋给x。x是函数的局部变量。所以，当我们在函数内改变x的值的时候，在主块中定义的x不受影响。</p>
<p>在最后一个print语句中，我们证明了主块中的x的值确实没有受到影响。</p>
<h3 id="使用global语句">使用global语句</h3><p>如果你想要为一个定义在函数外的变量赋值，那么你就得告诉Python这个变量名不是局部的，而是 全局 的。我们使用global语句完成这一功能。没有global语句，是不可能为定义在函数外的变量赋值的。</p>
<p>你可以使用定义在函数外的变量的值（假设在函数内没有同名的变量）。然而，我并不鼓励你这样做，并且你应该尽量避免这样做，因为这使得程序的读者会不清楚这个变量是在哪里定义的。使用global语句可以清楚地表明变量是在外面的块定义的。</p>
<p><strong>例7.4 使用global语句</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: func_global.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'x is'</span>, x</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Changed local x to'</span>, x</span><br><span class="line"></span><br><span class="line">x = <span class="number">50</span></span><br><span class="line">func()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Value of x is'</span>, x</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/func_global.py" target="_blank" rel="external">code/func_global.py</a>)</p>
<h3 id="输出-11">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> func_global.<span class="keyword">py</span></span><br><span class="line"><span class="keyword">x</span> <span class="keyword">is</span> <span class="number">50</span></span><br><span class="line">Changed <span class="keyword">global</span> <span class="keyword">x</span> <span class="keyword">to</span> <span class="number">2</span></span><br><span class="line">Value of <span class="keyword">x</span> <span class="keyword">is</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-10">它如何工作</h3><p>global语句被用来声明x是全局的——因此，当我们在函数内把值赋给x的时候，这个变化也反映在我们在主块中使用x的值的时候。</p>
<p>你可以使用同一个global语句指定多个全局变量。例如global x, y, z。</p>
<h2 id="默认参数值">默认参数值</h2><p>对于一些函数，你可能希望它的一些参数是 可选 的，如果用户不想要为这些参数提供值的话，这些参数就使用默认值。这个功能借助于默认参数值完成。你可以在函数定义的形参名后加上赋值运算符（=）和默认值，从而给形参指定默认参数值。</p>
<p>注意，默认参数值应该是一个参数。更加准确的说，默认参数值应该是不可变的——这会在后面的章节中做详细解释。从现在开始，请记住这一点。</p>
<h3 id="使用默认参数值">使用默认参数值</h3><p><strong>例7.5 使用默认参数值</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: func_default.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(message, times = <span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> message * times</span><br><span class="line"></span><br><span class="line">say(<span class="string">'Hello'</span>)</span><br><span class="line">say(<span class="string">'World'</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/func_default.py" target="_blank" rel="external">code/func_default.py</a>)</p>
<h3 id="输出-12">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python func_default<span class="class">.py</span></span><br><span class="line">Hello</span><br><span class="line">WorldWorldWorldWorldWorld</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-11">它如何工作</h3><p>名为say的函数用来打印一个字符串任意所需的次数。如果我们不提供一个值，那么默认地，字符串将只被打印一遍。我们通过给形参times指定默认参数值1来实现这一功能。</p>
<p>在第一次使用say的时候，我们只提供一个字符串，函数只打印一次字符串。在第二次使用say的时候，我们提供了字符串和参数5，表明我们想要 说 这个字符串消息5遍。</p>
<blockquote>
<p><strong>重要</strong> </p>
<p>只有在形参表末尾的那些参数可以有默认参数值，即你不能在声明函数形参的时候，先声明有默认值的形参而后声明没有默认值的形参。<br>这是因为赋给形参的值是根据位置而赋值的。例如，def func(a, b=5)是有效的，但是def func(a=5, b)是 无效 的。</p>
</blockquote>
<h2 id="关键参数">关键参数</h2><p>如果你的某个函数有许多参数，而你只想指定其中的一部分，那么你可以通过命名来为这些参数赋值——这被称作 关键参数 ——我们使用名字（关键字）而不是位置（我们前面所一直使用的方法）来给函数指定实参。</p>
<p>这样做有两个 优势 ——一，由于我们不必担心参数的顺序，使用函数变得更加简单了。二、假设其他参数都有默认值，我们可以只给我们想要的那些参数赋值。</p>
<h3 id="使用关键参数">使用关键参数</h3><p><strong>例7.6 使用关键参数</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: func_key.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b=<span class="number">5</span>, c=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'a is'</span>, a, <span class="string">'and b is'</span>, b, <span class="string">'and c is'</span>, c</span><br><span class="line"></span><br><span class="line">func(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">func(<span class="number">25</span>, c=<span class="number">24</span>)</span><br><span class="line">func(c=<span class="number">50</span>, a=<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/func_key.py" target="_blank" rel="external">code/func_key.py</a>)</p>
<h3 id="输出-13">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> func_key.<span class="keyword">py</span></span><br><span class="line"><span class="keyword">a</span> <span class="keyword">is</span> <span class="number">3</span> <span class="built_in">and</span> <span class="keyword">b</span> <span class="keyword">is</span> <span class="number">7</span> <span class="built_in">and</span> <span class="keyword">c</span> <span class="keyword">is</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">a</span> <span class="keyword">is</span> <span class="number">25</span> <span class="built_in">and</span> <span class="keyword">b</span> <span class="keyword">is</span> <span class="number">5</span> <span class="built_in">and</span> <span class="keyword">c</span> <span class="keyword">is</span> <span class="number">24</span></span><br><span class="line"><span class="keyword">a</span> <span class="keyword">is</span> <span class="number">100</span> <span class="built_in">and</span> <span class="keyword">b</span> <span class="keyword">is</span> <span class="number">5</span> <span class="built_in">and</span> <span class="keyword">c</span> <span class="keyword">is</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<p>名为func的函数有一个没有默认值的参数，和两个有默认值的参数。</p>
<p>在第一次使用函数的时候， func(3, 7)，参数a得到值3，参数b得到值7，而参数c使用默认值10。</p>
<p>在第二次使用函数func(25, c=24)的时候，根据实参的位置变量a得到值25。根据命名，即关键参数，参数c得到值24。变量b根据默认值，为5。</p>
<p>在第三次使用func(c=50, a=100)的时候，我们使用关键参数来完全指定参数值。注意，尽管函数定义中，a在c之前定义，我们仍然可以在a之前指定参数c的值。</p>
<h2 id="return语句">return语句</h2><p>return语句用来从一个函数 返回 即跳出函数。我们也可选从函数 返回一个值 。</p>
<h3 id="使用字面意义上的语句">使用字面意义上的语句</h3><p><strong>例7.7 使用字面意义上的语句</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: func_return.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maximum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> maximum(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/func_return.py" target="_blank" rel="external">code/func_return.py</a>)</p>
<h3 id="输出-14">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python func_return<span class="class">.py</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-12">它如何工作</h3><p>maximum函数返回参数中的最大值，在这里是提供给函数的数。它使用简单的if..else语句来找出较大的值，然后 返回 那个值。</p>
<p>注意，没有返回值的return语句等价于return None。None是Python中表示没有任何东西的特殊类型。例如，如果一个变量的值为None，可以表示它没有值。</p>
<p>除非你提供你自己的return语句，每个函数都在结尾暗含有return None语句。通过运行print someFunction()，你可以明白这一点，函数someFunction没有使用return语句，如同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">someFunction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>pass语句在Python中表示一个空的语句块。</p>
<h2 id="DocStrings">DocStrings</h2><p>Python有一个很奇妙的特性，称为 文档字符串 ，它通常被简称为 docstrings 。DocStrings是一个重要的工具，由于它帮助你的程序文档更加简单易懂，你应该尽量使用它。你甚至可以在程序运行的时候，从函数恢复文档字符串！</p>
<h3 id="使用DocStrings">使用DocStrings</h3><p><strong>例7.8 使用DocStrings</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: func_doc.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printMax</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="string">'''Prints the maximum of two numbers.</span><br><span class="line"></span><br><span class="line">    The two values must be integers.'''</span></span><br><span class="line">    x = int(x) <span class="comment"># convert to integers, if possible</span></span><br><span class="line">    y = int(y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">print</span> x, <span class="string">'is maximum'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> y, <span class="string">'is maximum'</span></span><br><span class="line"></span><br><span class="line">printMax(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> printMax.__doc__</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/func_doc.py" target="_blank" rel="external">code/func_doc.py</a>)</p>
<h3 id="输出-15">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> func_doc.<span class="keyword">py</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> maximum</span><br><span class="line">Prints the maximum of two numbers.</span><br><span class="line"></span><br><span class="line">        The two <span class="built_in">values</span> must <span class="keyword">be</span> integers.</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-13">它如何工作</h3><p>在函数的第一个逻辑行的字符串是这个函数的 文档字符串 。注意，DocStrings也适用于模块和类，我们会在后面相应的章节学习它们。</p>
<p>文档字符串的惯例是一个多行字符串，它的首行以大写字母开始，句号结尾。第二行是空行，从第三行开始是详细的描述。 强烈建议 你在你的函数中使用文档字符串时遵循这个惯例。</p>
<p>你可以使用<strong>doc</strong>（注意双下划线）调用printMax函数的文档字符串属性（属于函数的名称）。请记住Python把 每一样东西 都作为对象，包括这个函数。我们会在后面的类一章学习更多关于对象的知识。</p>
<p>如果你已经在Python中使用过help()，那么你已经看到过DocStings的使用了！它所做的只是抓取函数的<strong>doc</strong>属性，然后整洁地展示给你。你可以对上面这个函数尝试一下——只是在你的程序中包括help(printMax)。记住按 <strong>q</strong>  退出help。</p>
<p>自动化工具也可以以同样的方式从你的程序中提取文档。因此，我 强烈建议 你对你所写的任何正式函数编写文档字符串。随你的Python发行版附带的 <strong>pydoc</strong>  命令，与help()类似地使用DocStrings。    </p>
<h2 id="概括-6">概括</h2><p>我们已经学习了函数的很多方面的知识，不过注意还有一些方面我们没有涉及。然而，我们已经覆盖了大多数在日常使用中，你可能用到的Python函数知识。</p>
<p>接下来，我们将学习如何创建和使用Python模块。</p>
<h1 id="模块">模块</h1><h2 id="简介-5">简介</h2><p>你已经学习了如何在你的程序中定义一次函数而重用代码。如果你想要在其他程序中重用很多函数，那么你该如何编写程序呢？你可能已经猜到了，答案是使用模块。模块基本上就是一个包含了所有你定义的函数和变量的文件。为了在其他程序中重用模块，模块的文件名 <strong>必须</strong> 以.py为扩展名。</p>
<p>模块可以从其他程序 输入 以便利用它的功能。这也是我们使用Python标准库的方法。首先，我们将学习如何使用标准库模块。</p>
<h3 id="使用sys模块">使用sys模块</h3><p><strong>例8.1 使用sys模块</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_sys.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'The command line arguments are:'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="keyword">print</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'\n\nThe PYTHONPATH is'</span>, sys.path, <span class="string">'\n'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/using_sys.py" target="_blank" rel="external">code/using_sys.py</a>）</p>
<h3 id="输出-16">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python using_sys<span class="class">.py</span> we are arguments</span><br><span class="line">The command line arguments are:</span><br><span class="line">using_sys<span class="class">.py</span></span><br><span class="line">we</span><br><span class="line">are</span><br><span class="line">arguments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The PYTHONPATH is [<span class="string">'/home/swaroop/byte/code'</span>, <span class="string">'/usr/lib/python23.zip'</span>,</span><br><span class="line"><span class="string">'/usr/lib/python2.3'</span>, <span class="string">'/usr/lib/python2.3/plat-linux2'</span>,</span><br><span class="line"><span class="string">'/usr/lib/python2.3/lib-tk'</span>, <span class="string">'/usr/lib/python2.3/lib-dynload'</span>,</span><br><span class="line"><span class="string">'/usr/lib/python2.3/site-packages'</span>, <span class="string">'/usr/lib/python2.3/site-packages/gtk-2.0'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-14">它如何工作</h3><p>首先，我们利用import语句 输入 sys模块。基本上，这句语句告诉Python，我们想要使用这个模块。sys模块包含了与Python解释器和它的环境有关的函数。</p>
<p>当Python执行import sys语句的时候，它在sys.path变量中所列目录中寻找sys.py模块。如果找到了这个文件，这个模块的主块中的语句将被运行，然后这个模块将能够被你 使用 。注意，初始化过程仅在我们 第一次 输入模块的时候进行。另外，“sys”是“system”的缩写。</p>
<p>sys模块中的argv变量通过使用点号指明——sys.argv——这种方法的一个优势是这个名称不会与任何在你的程序中使用的argv变量冲突。另外，它也清晰地表明了这个名称是sys模块的一部分。</p>
<p>sys.argv变量是一个字符串的 列表 （列表会在后面的章节详细解释）。特别地，sys.argv包含了 命令行参数 的列表，即使用命令行传递给你的程序的参数。</p>
<p>如果你使用IDE编写运行这些程序，请在菜单里寻找一个指定程序的命令行参数的方法。</p>
<p>这里，当我们执行python using_sys.py we are arguments的时候，我们使用python命令运行using_sys.py模块，后面跟着的内容被作为参数传递给程序。Python为我们把它存储在sys.argv变量中。</p>
<p>记住，脚本的名称总是sys.argv列表的第一个参数。所以，在这里，’using_sys.py’是sys.argv[0]、’we’是sys.argv[1]、’are’是sys.argv[2]以及’arguments’是sys.argv[3]。注意，Python从0开始计数，而非从1开始。</p>
<p>sys.path包含输入模块的目录名列表。我们可以观察到sys.path的第一个字符串是空的——这个空的字符串表示当前目录也是sys.path的一部分，这与PYTHONPATH环境变量是相同的。这意味着你可以直接输入位于当前目录的模块。否则，你得把你的模块放在sys.path所列的目录之一。</p>
<h2 id="字节编译的-pyc文件">字节编译的.pyc文件</h2><p>输入一个模块相对来说是一个比较费时的事情，所以Python做了一些技巧，以便使输入模块更加快一些。一种方法是创建 字节编译的文件 ，这些文件以.pyc作为扩展名。字节编译的文件与Python变换程序的中间状态有关（是否还记得Python如何工作的介绍？）。当你在下次从别的程序输入这个模块的时候，.pyc文件是十分有用的——它会快得多，因为一部分输入模块所需的处理已经完成了。另外，这些字节编译的文件也是与平台无关的。所以，现在你知道了那些.pyc文件事实上是什么了。</p>
<h2 id="from-import语句">from..import语句</h2><p>如果你想要直接输入argv变量到你的程序中（避免在每次使用它时打sys.），那么你可以使用from sys import argv语句。如果你想要输入所有sys模块使用的名字，那么你可以使用from sys import *语句。这对于所有模块都适用。一般说来，应该避免使用from..import而使用import语句，因为这样可以使你的程序更加易读，也可以避免名称的冲突。</p>
<h2 id="模块的_name_">模块的_<em>name_</em></h2><p>每个模块都有一个名称，在模块中可以通过语句来找出模块的名称。这在一个场合特别有用——就如前面所提到的，当一个模块被第一次输入的时候，这个模块的主块将被运行。假如我们只想在程序本身被使用的时候运行主块，而在它被别的模块输入的时候不运行主块，我们该怎么做呢？这可以通过模块的<strong>name</strong>属性完成。</p>
<h3 id="使用模块的_name_">使用模块的_<em>name_</em></h3><p><strong>例8.2 使用模块的<strong>name</strong></strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'This program is being run by itself'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'I am being imported from another module'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/using_name.py" target="_blank" rel="external">code/using_name.py</a>）</p>
<h3 id="输出-17">输出</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python using_name.py</span><br><span class="line"><span class="constant">This</span> program is being run by itself</span><br><span class="line"></span><br><span class="line"><span class="variable">$ </span>python</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import using_name</span><br><span class="line"><span class="constant">I</span> am being imported from another <span class="class"><span class="keyword">module</span></span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-15">它如何工作</h3><p>每个Python模块都有它的__name_<em>，如果它是’\</em>_main__’，这说明这个模块被用户单独运行，我们可以进行相应的恰当操作。</p>
<h2 id="制造你自己的模块">制造你自己的模块</h2><p>创建你自己的模块是十分简单的，你一直在这样做！每个Python程序也是一个模块。你已经确保它具有.py扩展名了。下面这个例子将会使它更加清晰。</p>
<h3 id="创建你自己的模块">创建你自己的模块</h3><p><strong>例8.3 如何创建你自己的模块</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: mymodule.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Hi, this is mymodule speaking.'</span></span><br><span class="line"></span><br><span class="line">version = <span class="string">'0.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># End of mymodule.py</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/mymodule.py" target="_blank" rel="external">code/mymodule.py</a>）</p>
<p>上面是一个 模块 的例子。你已经看到，它与我们普通的Python程序相比并没有什么特别之处。我们接下来将看看如何在我们别的Python程序中使用这个模块。</p>
<p>记住这个模块应该被放置在我们输入它的程序的同一个目录中，或者在sys.path所列目录之一。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: mymodule_demo.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mymodule</span><br><span class="line"></span><br><span class="line">mymodule.sayhi()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Version'</span>, mymodule.version</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/mymodule_demo.py" target="_blank" rel="external">code/mymodule_demo.py</a>）</p>
<h3 id="输出-18">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> mymodule_demo.<span class="keyword">py</span></span><br><span class="line">Hi, this <span class="keyword">is</span> mymodule speaking.</span><br><span class="line">Version <span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-16">它如何工作</h3><p>注意我们使用了相同的点号来使用模块的成员。Python很好地重用了相同的记号来，使我们这些Python程序员不需要不断地学习新的方法。</p>
<h3 id="from-import">from..import</h3><p>下面是一个使用from..import语法的版本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: mymodule_demo2.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> mymodule <span class="keyword">import</span> sayhi, version</span><br><span class="line"><span class="comment"># Alternative:</span></span><br><span class="line"><span class="comment"># from mymodule import *</span></span><br><span class="line"></span><br><span class="line">sayhi()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Version'</span>, version</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/mymodule_demo2.py" target="_blank" rel="external">code/mymodule_demo2.py</a>）</p>
<p>mymodule_demo2.py的输出与mymodule_demo.py完全相同。</p>
<h2 id="dir()函数">dir()函数</h2><p>你可以使用内建的dir函数来列出模块定义的标识符。标识符有函数、类和变量。</p>
<p>当你为dir()提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当前模块中定义的名称列表。</p>
<h3 id="使用dir函数">使用dir函数</h3><p><strong>例8.4 使用dir函数</strong> </p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import sys</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dir(sys) <span class="comment"># get list of attributes for sys module</span></span><br><span class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__name__'</span>, <span class="string">'__stderr__'</span>,</span><br><span class="line"><span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>, <span class="string">'_getframe'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>,</span><br><span class="line"><span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>, <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>,</span><br><span class="line"><span class="string">'copyright'</span>, <span class="string">'displayhook'</span>, <span class="string">'exc_clear'</span>, <span class="string">'exc_info'</span>, <span class="string">'exc_type'</span>,</span><br><span class="line"><span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>, <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'getcheckinterval'</span>,</span><br><span class="line"><span class="string">'getdefaultencoding'</span>, <span class="string">'getdlopenflags'</span>, <span class="string">'getfilesystemencoding'</span>,</span><br><span class="line"><span class="string">'getrecursionlimit'</span>, <span class="string">'getrefcount'</span>, <span class="string">'hexversion'</span>, <span class="string">'maxint'</span>, <span class="string">'maxunicode'</span>,</span><br><span class="line"><span class="string">'meta_path'</span>,<span class="string">'modules'</span>, <span class="string">'path'</span>, <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>,</span><br><span class="line"><span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>, <span class="string">'ps2'</span>, <span class="string">'setcheckinterval'</span>, <span class="string">'setdlopenflags'</span>,</span><br><span class="line"><span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>,</span><br><span class="line"><span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dir() <span class="comment"># get list of attributes for current module</span></span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'sys'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br><span class="line">&gt;&gt;&gt; a = <span class="number">5</span> <span class="comment"># create a new variable 'a'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; dir()</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'a'</span>, <span class="string">'sys'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br><span class="line">&gt;&gt;&gt; del a <span class="comment"># delete/remove a name</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br><span class="line">&gt;&gt;&gt; dir()</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'sys'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-17">它如何工作</h3><p>首先，我们来看一下在输入的sys模块上使用dir。我们看到它包含一个庞大的属性列表。</p>
<p>接下来，我们不给dir函数传递参数而使用它——默认地，它返回当前模块的属性列表。注意，输入的模块同样是列表的一部分。</p>
<p>为了观察dir的作用，我们定义一个新的变量a并且给它赋一个值，然后检验dir，我们观察到在列表中增加了以上相同的值。我们使用del语句删除当前模块中的变量/属性，这个变化再一次反映在dir的输出中。</p>
<p>关于del的一点注释——这个语句在运行后被用来 删除 一个变量/名称。在这个例子中，del a，你将无法再使用变量a——它就好像从来没有存在过一样。</p>
<h2 id="概括-7">概括</h2><p>模块的用处在于它能为你在别的程序中重用它提供的服务和功能。Python附带的标准库就是这样一组模块的例子。我们已经学习了如何使用这些模块以及如何创造我们自己的模块。</p>
<p>接下来，我们将学习一些有趣的概念，它们称为数据结构。</p>
<h1 id="数据结构">数据结构</h1><h2 id="简介-6">简介</h2><p>数据结构基本上就是——它们是可以处理一些 数据 的 结构 。或者说，它们是用来存储一组相关数据的。</p>
<p>在Python中有三种内建的数据结构——列表、元组和字典。我们将会学习如何使用它们，以及它们如何使编程变得简单。</p>
<h2 id="列表">列表</h2><p>list是处理一组有序项目的数据结构，即你可以在一个列表中存储一个 序列 的项目。假想你有一个购物列表，上面记载着你要买的东西，你就容易理解列表了。只不过在你的购物表上，可能每样东西都独自占有一行，而在Python中，你在每个项目之间用逗号分割。</p>
<p>列表中的项目应该包括在方括号中，这样Python就知道你是在指明一个列表。一旦你创建了一个列表，你可以添加、删除或是搜索列表中的项目。由于你可以增加或删除项目，我们说列表是 可变的 数据类型，即这种类型是可以被改变的。</p>
<h3 id="对象与类的快速入门">对象与类的快速入门</h3><p>尽管我一直推迟讨论对象和类，但是现在对它们做一点解释可以使你更好的理解列表。我们会在相应的章节详细探索这个主题。</p>
<p>列表是使用对象和类的一个例子。当你使用变量i并给它赋值的时候，比如赋整数5，你可以认为你创建了一个类（类型）int的对象（实例）i。事实上，你可以看一下help(int)以更好地理解这一点。</p>
<p>类也有方法，即仅仅为类而定义地函数。仅仅在你有一个该类的对象的时候，你才可以使用这些功能。例如，Python为list类提供了append方法，这个方法让你在列表尾添加一个项目。例如mylist.append(‘an item’)列表mylist中增加那个字符串。注意，使用点号来使用对象的方法。</p>
<p>一个类也有域，它是仅仅为类而定义的变量。仅仅在你有一个该类的对象的时候，你才可以使用这些变量/名称。类也通过点号使用，例如mylist.field。</p>
<h3 id="使用列表">使用列表</h3><p><strong>例9.1 使用列表</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_list.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is my shopping list</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'I have'</span>, len(shoplist),<span class="string">'items to purchase.'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'These items are:'</span>, <span class="comment"># Notice the comma at end of the line</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> shoplist:</span><br><span class="line">    <span class="keyword">print</span> item,</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nI also have to buy rice.'</span></span><br><span class="line">shoplist.append(<span class="string">'rice'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'My shopping list is now'</span>, shoplist</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'I will sort my list now'</span></span><br><span class="line">shoplist.sort()</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Sorted shopping list is'</span>, shoplist</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'The first item I will buy is'</span>, shoplist[<span class="number">0</span>]</span><br><span class="line">olditem = shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">del</span> shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'I bought the'</span>, olditem</span><br><span class="line"><span class="keyword">print</span> <span class="string">'My shopping list is now'</span>, shoplist</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/using_list.py" target="_blank" rel="external">code/using_list.py</a>）</p>
<h3 id="输出-19">输出</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python using_list.py</span><br><span class="line">I have <span class="number">4</span> <span class="keyword">items</span> <span class="built_in">to</span> purchase.</span><br><span class="line">These <span class="keyword">items</span> are: apple mango carrot banana</span><br><span class="line">I also have <span class="built_in">to</span> buy rice.</span><br><span class="line">My shopping list is now [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>, <span class="string">'rice'</span>]</span><br><span class="line">I will <span class="built_in">sort</span> my list now</span><br><span class="line">Sorted shopping list is [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'carrot'</span>, <span class="string">'mango'</span>, <span class="string">'rice'</span>]</span><br><span class="line">The <span class="keyword">first</span> <span class="keyword">item</span> I will buy is apple</span><br><span class="line">I bought <span class="operator">the</span> apple</span><br><span class="line">My shopping list is now [<span class="string">'banana'</span>, <span class="string">'carrot'</span>, <span class="string">'mango'</span>, <span class="string">'rice'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-18">它如何工作</h3><p>变量shoplist是某人的购物列表。在shoplist中，我们只存储购买的东西的名字字符串，但是记住，你可以在列表中添加 任何种类的对象 包括数甚至其他列表。</p>
<p>我们也使用了for..in循环在列表中各项目间递归。从现在开始，你一定已经意识到列表也是一个序列。序列的特性会在后面的章节中讨论。</p>
<p>注意，我们在print语句的结尾使用了一个 逗号 来消除每个print语句自动打印的换行符。这样做有点难看，不过确实简单有效。</p>
<p>接下来，我们使用append方法在列表中添加了一个项目，就如前面已经讨论过的一样。然后我们通过打印列表的内容来检验这个项目是否确实被添加进列表了。打印列表只需简单地把列表传递给print语句，我们可以得到一个整洁的输出。</p>
<p>再接下来，我们使用列表的sort方法来对列表排序。需要理解的是，这个方法影响列表本身，而不是返回一个修改后的列表——这与字符串工作的方法不同。这就是我们所说的列表是 可变的 而字符串是 不可变的 。</p>
<p>最后，但我们完成了在市场购买一样东西的时候，我们想要把它从列表中删除。我们使用del语句来完成这个工作。这里，我们指出我们想要删除列表中的哪个项目，而del语句为我们从列表中删除它。我们指明我们想要删除列表中的第一个元素，因此我们使用del shoplist[0]（记住，Python从0开始计数）。</p>
<p>如果你想要知道列表对象定义的所有方法，可以通过help(list)获得完整的知识。</p>
<h2 id="元组">元组</h2><p>元组和列表十分类似，只不过元组和字符串一样是 不可变的 即你不能修改元组。元组通过圆括号中用逗号分割的项目定义。元组通常用在使语句或用户定义的函数能够安全地采用一组值的时候，即被使用的元组的值不会改变。</p>
<h3 id="使用元组">使用元组</h3><p><strong>例9.2 使用元组</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_tuple.py</span></span><br><span class="line"></span><br><span class="line">zoo = (<span class="string">'wolf'</span>, <span class="string">'elephant'</span>, <span class="string">'penguin'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Number of animals in the zoo is'</span>, len(zoo)</span><br><span class="line"></span><br><span class="line">new_zoo = (<span class="string">'monkey'</span>, <span class="string">'dolphin'</span>, zoo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Number of animals in the new zoo is'</span>, len(new_zoo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'All animals in new zoo are'</span>, new_zoo</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Animals brought from old zoo are'</span>, new_zoo[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Last animal brought from old zoo is'</span>, new_zoo[<span class="number">2</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/using_tuple.py" target="_blank" rel="external">code/using_tuple.py</a>）</p>
<h3 id="输出-20">输出</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python using_tuple.py</span><br><span class="line">Number <span class="keyword">of</span> animals <span class="keyword">in</span> the zoo <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line">Number <span class="keyword">of</span> animals <span class="keyword">in</span> the <span class="keyword">new</span> zoo <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line">All animals <span class="keyword">in</span> <span class="keyword">new</span> zoo are (<span class="string">'monkey'</span>, <span class="string">'dolphin'</span>, (<span class="string">'wolf'</span>, <span class="string">'elephant'</span>, <span class="string">'penguin'</span>))</span><br><span class="line">Animals brought <span class="keyword">from</span> <span class="keyword">old</span> zoo are (<span class="string">'wolf'</span>, <span class="string">'elephant'</span>, <span class="string">'penguin'</span>)</span><br><span class="line">Last animal brought <span class="keyword">from</span> <span class="keyword">old</span> zoo <span class="keyword">is</span> penguin</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-19">它如何工作</h3><p>变量zoo是一个元组，我们看到len函数可以用来获取元组的长度。这也表明元组也是一个序列。</p>
<p>由于老动物园关闭了，我们把动物转移到新动物园。因此，new_zoo元组包含了一些已经在那里的动物和从老动物园带过来的动物。回到话题，注意元组之内的元组不会失去它的身份。</p>
<p>我们可以通过一对方括号来指明某个项目的位置从而来访问元组中的项目，就像我们对列表的用法一样。这被称作 索引 运算符。我们使用new_zoo[2]来访问new_zoo中的第三个项目。我们使用new_zoo[2][2]来访问new_zoo元组的第三个项目的第三个项目。</p>
<p>含有0个或1个项目的元组。一个空的元组由一对空的圆括号组成，如myempty = ()。然而，含有单个元素的元组就不那么简单了。你必须在第一个（唯一一个）项目后跟一个逗号，这样Python才能区分元组和表达式中一个带圆括号的对象。即如果你想要的是一个包含项目2的元组的时候，你应该指明singleton = (2 , )。</p>
<blockquote>
<p><strong>给Perl程序员的注释</strong> </p>
<p>列表之中的列表不会失去它的身份，即列表不会像Perl中那样被打散。同样元组中的元组，或列表中的元组，或元组中的列表等等都是如此。只要是Python，它们就只是使用另一个对象存储的对象。</p>
</blockquote>
<h3 id="元组与打印语句">元组与打印语句</h3><p>元组最通常的用法是用在打印语句中，下面是一个例子：</p>
<p><strong>例9.3 使用元组输出</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: print_tuple.py</span></span><br><span class="line"></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">name = <span class="string">'Swaroop'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'%s is %d years old'</span> % (name, age)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Why is %s playing with that python?'</span> % name</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/print_tuple.py" target="_blank" rel="external">code/print_tuple.py</a>）</p>
<h3 id="输出-21">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> print_tuple.<span class="keyword">py</span></span><br><span class="line">Swaroop <span class="keyword">is</span> <span class="number">22</span> years old</span><br><span class="line">Why <span class="keyword">is</span> Swaroop playing with that <span class="keyword">python</span>?</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-20">它如何工作</h3><p>print语句可以使用跟着%符号的项目元组的字符串。这些字符串具备定制的功能。定制让输出满足某种特定的格式。定制可以是%s表示字符串或%d表示整数。元组必须按照相同的顺序来对应这些定制。</p>
<p>观察我们使用的第一个元组，我们首先使用%s，这对应变量name，它是元组中的第一个项目。而第二个定制是%d，它对应元组的第二个项目age。</p>
<p>Python在这里所做的是把元组中的每个项目转换成字符串并且用字符串的值替换定制的位置。因此%s被替换为变量name的值，依此类推。</p>
<p>print的这个用法使得编写输出变得极其简单，它避免了许多字符串操作。它也避免了我们一直以来使用的逗号。</p>
<p>在大多数时候，你可以只使用%s定制，而让Python来提你处理剩余的事情。这种方法对数同样奏效。然而，你可能希望使用正确的定制，从而可以避免多一层的检验程序是否正确。</p>
<p>在第二个print语句中，我们使用了一个定制，后面跟着%符号后的单个项目——没有圆括号。这只在字符串中只有一个定制的时候有效。</p>
<h2 id="字典">字典</h2><p>字典类似于你通过联系人名字查找地址和联系人详细情况的地址簿，即，我们把键（名字）和值（详细情况）联系在一起。注意，键必须是唯一的，就像如果有两个人恰巧同名的话，你无法找到正确的信息。</p>
<p>注意，你只能使用不可变的对象（比如字符串）来作为字典的键，但是你可以不可变或可变的对象作为字典的值。基本说来就是，你应该只使用简单的对象作为键。</p>
<p>键值对在字典中以这样的方式标记：d = {key1 : value1, key2 : value2 }。注意它们的键/值对用冒号分割，而各个对用逗号分割，所有这些都包括在花括号中。</p>
<p>记住字典中的键/值对是没有顺序的。如果你想要一个特定的顺序，那么你应该在使用前自己对它们排序。</p>
<p>字典是dict类的实例/对象。</p>
<h3 id="使用字典">使用字典</h3><p><strong>例9.4 使用字典</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_dict.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 'ab' is short for 'a'ddress'b'ook</span></span><br><span class="line"></span><br><span class="line">ab = &#123;       <span class="string">'Swaroop'</span>   : <span class="string">'swaroopch@byteofpython.info'</span>,</span><br><span class="line">             <span class="string">'Larry'</span>     : <span class="string">'larry@wall.org'</span>,</span><br><span class="line">             <span class="string">'Matsumoto'</span> : <span class="string">'matz@ruby-lang.org'</span>,</span><br><span class="line">             <span class="string">'Spammer'</span>   : <span class="string">'spammer@hotmail.com'</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">"Swaroop's address is %s"</span> % ab[<span class="string">'Swaroop'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding a key/value pair</span></span><br><span class="line">ab[<span class="string">'Guido'</span>] = <span class="string">'guido@python.org'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deleting a key/value pair</span></span><br><span class="line"><span class="keyword">del</span> ab[<span class="string">'Spammer'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'\nThere are %d contacts in the address-book\n'</span> % len(ab)</span><br><span class="line"><span class="keyword">for</span> name, address <span class="keyword">in</span> ab.items():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Contact %s at %s'</span> % (name, address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'Guido'</span> <span class="keyword">in</span> ab: <span class="comment"># OR ab.has_key('Guido')</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"\nGuido's address is %s"</span> % ab[<span class="string">'Guido'</span>]</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/using_dict.py" target="_blank" rel="external">code/using_dict.py</a>）</p>
<h3 id="输出-22">输出</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>python using_dict.py</span><br><span class="line"><span class="constant">Swaroop'</span>s address is swaroopch<span class="variable">@byteofpython</span>.info</span><br><span class="line"></span><br><span class="line"><span class="constant">There </span>are <span class="number">4</span> contacts <span class="keyword">in</span> the address-book</span><br><span class="line"></span><br><span class="line"><span class="constant">Contact Swaroop </span>at swaroopch<span class="variable">@byteofpython</span>.info</span><br><span class="line"><span class="constant">Contact Matsumoto </span>at matz<span class="variable">@ruby</span>-lang.org</span><br><span class="line"><span class="constant">Contact Larry </span>at larry<span class="variable">@wall</span>.org</span><br><span class="line"><span class="constant">Contact Guido </span>at guido<span class="variable">@python</span>.org</span><br><span class="line"></span><br><span class="line"><span class="constant">Guido'</span>s address is guido<span class="variable">@python</span>.org</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-21">它如何工作</h3><p>我们使用已经介绍过的标记创建了字典ab。然后我们使用在列表和元组章节中已经讨论过的索引操作符来指定键，从而使用键/值对。我们可以看到字典的语法同样十分简单。</p>
<p>我们可以使用索引操作符来寻址一个键并为它赋值，这样就增加了一个新的键/值对，就像在上面的例子中我们对Guido所做的一样。</p>
<p>我们可以使用我们的老朋友——del语句来删除键/值对。我们只需要指明字典和用索引操作符指明要删除的键，然后把它们传递给del语句就可以了。执行这个操作的时候，我们无需知道那个键所对应的值。</p>
<p>接下来，我们使用字典的items方法，来使用字典中的每个键/值对。这会返回一个元组的列表，其中每个元组都包含一对项目——键与对应的值。我们抓取这个对，然后分别赋给for..in循环中的变量name和address然后在for－块中打印这些值。</p>
<p>我们可以使用in操作符来检验一个键/值对是否存在，或者使用dict类的has_key方法。你可以使用help(dict)来查看dict类的完整方法列表。</p>
<p>关键字参数与字典。如果换一个角度看待你在函数中使用的关键字参数的话，你已经使用了字典了！只需想一下——你在函数定义的参数列表中使用的键/值对。当你在函数中使用变量的时候，它只不过是使用一个字典的键（这在编译器设计的术语中被称作 符号表 ）。</p>
<h2 id="序列">序列</h2><p>列表、元组和字符串都是序列，但是序列是什么，它们为什么如此特别呢？序列的两个主要特点是索引操作符和切片操作符。索引操作符让我们可以从序列中抓取一个特定项目。切片操作符让我们能够获取序列的一个切片，即一部分序列。</p>
<h3 id="使用序列">使用序列</h3><p><strong>例9.5 使用序列</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: seq.py</span></span><br><span class="line"></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Indexing or 'Subscription' operation</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 0 is'</span>, shoplist[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 is'</span>, shoplist[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 2 is'</span>, shoplist[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 3 is'</span>, shoplist[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item -1 is'</span>, shoplist[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item -2 is'</span>, shoplist[-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Slicing on a list</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 to 3 is'</span>, shoplist[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 2 to end is'</span>, shoplist[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item 1 to -1 is'</span>, shoplist[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Item start to end is'</span>, shoplist[:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Slicing on a string</span></span><br><span class="line">name = <span class="string">'swaroop'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 1 to 3 is'</span>, name[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 2 to end is'</span>, name[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters 1 to -1 is'</span>, name[<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">'characters start to end is'</span>, name[:]</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/seq.py" target="_blank" rel="external">code/seq.py</a>）</p>
<h3 id="输出-23">输出</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ python seq.py</span><br><span class="line">Item <span class="number">0</span> <span class="keyword">is</span> apple</span><br><span class="line">Item <span class="number">1</span> <span class="keyword">is</span> mango</span><br><span class="line">Item <span class="number">2</span> <span class="keyword">is</span> carrot</span><br><span class="line">Item <span class="number">3</span> <span class="keyword">is</span> banana</span><br><span class="line">Item -<span class="number">1</span> <span class="keyword">is</span> banana</span><br><span class="line">Item -<span class="number">2</span> <span class="keyword">is</span> carrot</span><br><span class="line">Item <span class="number">1</span> <span class="keyword">to</span> <span class="number">3</span> <span class="keyword">is</span> [<span class="string">'mango'</span>, <span class="string">'carrot'</span>]</span><br><span class="line">Item <span class="number">2</span> <span class="keyword">to</span> <span class="keyword">end</span> <span class="keyword">is</span> [<span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line">Item <span class="number">1</span> <span class="keyword">to</span> -<span class="number">1</span> <span class="keyword">is</span> [<span class="string">'mango'</span>, <span class="string">'carrot'</span>]</span><br><span class="line">Item start <span class="keyword">to</span> <span class="keyword">end</span> <span class="keyword">is</span> [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line">characters <span class="number">1</span> <span class="keyword">to</span> <span class="number">3</span> <span class="keyword">is</span> wa</span><br><span class="line">characters <span class="number">2</span> <span class="keyword">to</span> <span class="keyword">end</span> <span class="keyword">is</span> aroop</span><br><span class="line">characters <span class="number">1</span> <span class="keyword">to</span> -<span class="number">1</span> <span class="keyword">is</span> waroo</span><br><span class="line">characters start <span class="keyword">to</span> <span class="keyword">end</span> <span class="keyword">is</span> swaroop</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-22">它如何工作</h3><p>首先，我们来学习如何使用索引来取得序列中的单个项目。这也被称作是下标操作。每当你用方括号中的一个数来指定一个序列的时候，Python会为你抓取序列中对应位置的项目。记住，Python从0开始计数。因此，shoplist[0]抓取第一个项目，shoplist[3]抓取shoplist序列中的第四个元素。</p>
<p>索引同样可以是负数，在那样的情况下，位置是从序列尾开始计算的。因此，shoplist[-1]表示序列的最后一个元素而shoplist[-2]抓取序列的倒数第二个项目。</p>
<p>切片操作符是序列名后跟一个方括号，方括号中有一对可选的数字，并用冒号分割。注意这与你使用的索引操作符十分相似。记住数是可选的，而冒号是必须的。</p>
<p>切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束。如果不指定第一个数，Python就从序列首开始。如果没有指定第二个数，则Python会停止在序列尾。注意，返回的序列从开始位置 开始 ，刚好在 结束 位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。</p>
<p>这样，shoplist[1:3]返回从位置1开始，包括位置2，但是停止在位置3的一个序列切片，因此返回一个含有两个项目的切片。类似地，shoplist[:]返回整个序列的拷贝。</p>
<p>你可以用负数做切片。负数用在从序列尾开始计算的位置。例如，shoplist[:-1]会返回除了最后一个项目外包含所有项目的序列切片。</p>
<p>使用Python解释器交互地尝试不同切片指定组合，即在提示符下你能够马上看到结果。序列的神奇之处在于你可以用相同的方法访问元组、列表和字符串。</p>
<h2 id="参考">参考</h2><p>当你创建一个对象并给它赋一个变量的时候，这个变量仅仅 参考 那个对象，而不是表示这个对象本身！也就是说，变量名指向你计算机中存储那个对象的内存。这被称作名称到对象的绑定。</p>
<p>一般说来，你不需要担心这个，只是在参考上有些细微的效果需要你注意。这会通过下面这个例子加以说明。</p>
<h3 id="对象与参考">对象与参考</h3><p><strong>例9.6 对象与参考</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: reference.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Simple Assignment'</span></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line">mylist = shoplist <span class="comment"># mylist is just another name pointing to the same object!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> shoplist[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'shoplist is'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'mylist is'</span>, mylist</span><br><span class="line"><span class="comment"># notice that both shoplist and mylist both print the same list without</span></span><br><span class="line"><span class="comment"># the 'apple' confirming that they point to the same object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Copy by making a full slice'</span></span><br><span class="line">mylist = shoplist[:] <span class="comment"># make a copy by doing a full slice</span></span><br><span class="line"><span class="keyword">del</span> mylist[<span class="number">0</span>] <span class="comment"># remove first item</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'shoplist is'</span>, shoplist</span><br><span class="line"><span class="keyword">print</span> <span class="string">'mylist is'</span>, mylist</span><br><span class="line"><span class="comment"># notice that now the two lists are different</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/reference.py" target="_blank" rel="external">code/reference.py</a>）</p>
<h3 id="输出-24">输出</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">reference</span>.py</span><br><span class="line">Simple Assignment</span><br><span class="line">shoplist <span class="keyword">is</span> [<span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line">mylist <span class="keyword">is</span> [<span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="keyword">Copy</span> <span class="keyword">by</span> making a full slice</span><br><span class="line">shoplist <span class="keyword">is</span> [<span class="string">'mango'</span>, <span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br><span class="line">mylist <span class="keyword">is</span> [<span class="string">'carrot'</span>, <span class="string">'banana'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-23">它如何工作</h3><p>大多数解释已经在程序的注释中了。你需要记住的只是如果你想要复制一个列表或者类似的序列或者其他复杂的对象（不是如整数那样的简单 对象 ），那么你必须使用切片操作符来取得拷贝。如果你只是想要使用另一个变量名，两个名称都 参考 同一个对象，那么如果你不小心的话，可能会引来各种麻烦。</p>
<blockquote>
<p><strong>给Perl程序员的注释</strong> </p>
<p>记住列表的赋值语句不创建拷贝。你得使用切片操作符来建立序列的拷贝。</p>
</blockquote>
<h2 id="更多字符串的内容">更多字符串的内容</h2><p>我们已经在前面详细讨论了字符串。我们还需要知道什么呢？那么，你是否知道字符串也是对象，同样具有方法。这些方法可以完成包括检验一部分字符串和去除空格在内的各种工作。</p>
<p>你在程序中使用的字符串都是str类的对象。这个类的一些有用的方法会在下面这个例子中说明。如果要了解这些方法的完整列表，请参见help(str)</p>
<h3 id="字符串的方法">字符串的方法</h3><p><strong>例9.7 字符串的方法</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: str_methods.py</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">'Swaroop'</span> <span class="comment"># This is a string object </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name.startswith(<span class="string">'Swa'</span>):</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, the string starts with "Swa"'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">in</span> name:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, it contains the string "a"'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name.find(<span class="string">'war'</span>) != -<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Yes, it contains the string "war"'</span></span><br><span class="line"></span><br><span class="line">delimiter = <span class="string">'_*_'</span></span><br><span class="line">mylist = [<span class="string">'Brazil'</span>, <span class="string">'Russia'</span>, <span class="string">'India'</span>, <span class="string">'China'</span>]</span><br><span class="line"><span class="keyword">print</span> delimiter.join(mylist)</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/str_methods.py" target="_blank" rel="external">code/str_methods.py</a>）</p>
<h3 id="输出-25">输出</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python str_methods.py</span><br><span class="line">Yes, <span class="operator">the</span> <span class="keyword">string</span> starts <span class="operator">with</span> <span class="string">"Swa"</span></span><br><span class="line">Yes, <span class="keyword">it</span> <span class="operator">contains</span> <span class="operator">the</span> <span class="keyword">string</span> <span class="string">"a"</span></span><br><span class="line">Yes, <span class="keyword">it</span> <span class="operator">contains</span> <span class="operator">the</span> <span class="keyword">string</span> <span class="string">"war"</span></span><br><span class="line">Brazil_*_Russia_*_India_*_China</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-24">它如何工作</h3><p>这里，我们看到使用了许多字符串方法。startwith方法是用来测试字符串是否以给定字符串开始。in操作符用来检验一个给定字符串是否为另一个字符串的一部分。</p>
<p>find方法用来找出给定字符串在另一个字符串中的位置，或者返回-1以表示找不到子字符串。str类也有以一个作为分隔符的字符串join序列的项目的整洁的方法，它返回一个生成的大字符串。</p>
<h2 id="概括-8">概括</h2><p>我们已经详细探讨了多种Python内建的数据结构。这些数据结构将是编写程序时至关重要的部分。</p>
<p>现在我们已经掌握了很多Python的基本知识，我们接下来将学习如何设计和编写一个实用的Python程序。</p>
<h1 id="解决问题————编写一个Python脚本">解决问题————编写一个Python脚本</h1><p>我们已经研究了Python语言的众多内容，现在我们将来学习一下怎么把这些内容结合起来。我们将设计编写一个能够 做 一些确实有用的事情的程序。</p>
<h2 id="问题">问题</h2><p>我提出的问题是： 我想要一个可以为我的所有重要文件创建备份的程序。</p>
<p>尽管这是一个简单的问题，但是问题本身并没有给我们足够的信息来解决它。进一步的分析是必需的。例如，我们如何确定该备份哪些文件？备份保存在哪里？我们怎么样存储备份？</p>
<p>在恰当地分析了这个问题之后，我们开始设计我们的程序。我们列了一张表，表示我们的程序应该如何工作。对于这个问题，我已经创建了下面这个列表以说明 我 如何让它工作。如果是你设计的话，你可能不会这样来解决问题——每个人都有其做事的方法，这很正常。</p>
<ol>
<li>需要备份的文件和目录由一个列表指定。</li>
<li>备份应该保存在主备份目录中。</li>
<li>文件备份成一个zip文件。</li>
<li>zip存档的名称是当前的日期和时间。</li>
<li>我们使用标准的zip命令，它通常默认地随Linux/Unix发行版提供。Windows用户可以使用Info-Zip程序。注意你可以使用任何地存档命令，只要它有命令行界面就可以了，那样的话我们可以从我们的脚本中传递参数给它。</li>
</ol>
<h2 id="解决方案">解决方案</h2><p>当我们基本完成程序的设计，我们就可以编写代码了，它是对我们的解决方案的实施。</p>
<h3 id="版本一">版本一</h3><p><strong>例10.1 备份脚本——版本一</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: backup_ver1.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. The files and directories to be backed up are specified in a list.</span></span><br><span class="line">source = [<span class="string">'/home/swaroop/byte'</span>, <span class="string">'/home/swaroop/bin'</span>]</span><br><span class="line"><span class="comment"># If you are using Windows, use source = [r'C:\Documents', r'D:\Work'] or something like that</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. The backup must be stored in a main backup directory</span></span><br><span class="line">target_dir = <span class="string">'/mnt/e/backup/'</span> <span class="comment"># Remember to change this to what you will be using</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. The files are backed up into a zip file.</span></span><br><span class="line"><span class="comment"># 4. The name of the zip archive is the current date and time</span></span><br><span class="line">target = target_dir + time.strftime(<span class="string">'%Y%m%d%H%M%S'</span>) + <span class="string">'.zip'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. We use the zip command (in Unix/Linux) to put the files in a zip archive</span></span><br><span class="line">zip_command = <span class="string">"zip -qr '%s' %s"</span> % (target, <span class="string">' '</span>.join(source))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the backup</span></span><br><span class="line"><span class="keyword">if</span> os.system(zip_command) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Successful backup to'</span>, target</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Backup FAILED'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/backup_ver1.py" target="_blank" rel="external">code/backup_ver1.py</a>）</p>
<h3 id="输出-26">输出</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python backup_ver1.py</span><br><span class="line">Successful <span class="operator"><span class="keyword">backup</span> <span class="keyword">to</span> /mnt/e/<span class="keyword">backup</span>/<span class="number">20041208073244.</span>zip</span></span><br></pre></td></tr></table></figure>
<p>现在，我们已经处于测试环节了，在这个环节，我们测试我们的程序是否正确工作。如果它与我们所期望的不一样，我们就得调试我们的程序，即消除程序中的 瑕疵 （错误）。</p>
<h3 id="它如何工作-25">它如何工作</h3><p>接下来你将看到我们如何把 设计 一步一步地转换为 代码 。</p>
<p>我们使用了os和time模块，所以我们输入它们。然后，我们在source列表中指定需要备份的文件和目录。目标目录是我们想要存储备份文件的地方，它由target_dir变量指定。zip归档的名称是目前的日期和时间，我们使用time.strftime()函数获得。它还包括.zip扩展名，将被保存在target_dir目录中。</p>
<p>time.strftime()函数需要我们在上面的程序中使用的那种定制。%Y会被无世纪的年份所替代。%m会被01到12之间的一个十进制月份数替代，其他依次类推。这些定制的详细情况可以在《Python参考手册》中获得。《Python参考手册》包含在你的Python发行版中。注意这些定制与用于print语句的定制（%后跟一个元组）类似（但不完全相同）</p>
<p>我们使用加法操作符来 级连 字符串，即把两个字符串连接在一起返回一个新的字符串。通过这种方式，我们创建了目标zip文件的名称。接着我们创建了zip_command字符串，它包含我们将要执行的命令。你可以在shell（Linux终端或者DOS提示符）中运行它，以检验它是否工作。</p>
<p>zip命令有一些选项和参数。-q选项用来表示zip命令安静地工作。-r选项表示zip命令对目录递归地工作，即它包括子目录以及子目录中的文件。两个选项可以组合成缩写形式-qr。选项后面跟着待创建的zip归档的名称，然后再是待备份的文件和目录列表。我们使用已经学习过的字符串join方法把source列表转换为字符串。</p>
<p>最后，我们使用os.system函数 运行 命令，利用这个函数就好像在 系统 中运行命令一样。即在shell中运行命令——如果命令成功运行，它返回0，否则它返回错误号。</p>
<p>根据命令的输出，我们打印对应的消息，显示备份是否创建成功。好了，就是这样我们已经创建了一个脚本来对我们的重要文件做备份！</p>
<blockquote>
<p><strong>给Windows用户的注释</strong> </p>
<p>你可以把source列表和target目录设置成任何文件和目录名，但是在Windows中你得小心一些。问题是Windows把反斜杠（\）作为目录分隔符，而Python用反斜杠表示转义符！<br>所以，你得使用转义符来表示反斜杠本身或者使用自然字符串。例如，使用’C:\Documents’或r’C:\Documents’而不是’C:\Documents’——你在使用一个不知名的转义符\D！</p>
</blockquote>
<p>现在我们已经有了一个可以工作的备份脚本，我们可以在任何我们想要建立文件备份的时候使用它。建议Linux/Unix用户使用前面介绍的可执行的方法，这样就可以在任何地方任何时候运行备份脚本了。这被称为软件的实施环节或开发环节。</p>
<p>上面的程序可以正确工作，但是（通常）第一个程序并不是与你所期望的完全一样。例如，可能有些问题你没有设计恰当，又或者你在输入代码的时候发生了一点错误，等等。正常情况下，你应该回到设计环节或者调试程序。</p>
<h3 id="版本二">版本二</h3><p>第一个版本的脚本可以工作。然而，我们可以对它做些优化以便让它在我们的日常工作中变得更好。这称为软件的维护环节。</p>
<p>我认为优化之一是采用更好的文件名机制——使用 时间 作为文件名，而当前的 日期 作为目录名，存放在主备份目录中。这样做的一个优势是你的备份会以等级结构存储，因此它就更加容易管理了。另外一个优势是文件名的长度也可以变短。还有一个优势是采用各自独立的文件夹可以帮助你方便地检验你是否在每一天创建了备份，因为只有在你创建了备份，才会出现那天的目录。</p>
<p><strong>例10.2 备份脚本——版本二</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: backup_ver2.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. The files and directories to be backed up are specified in a list.</span></span><br><span class="line">source = [<span class="string">'/home/swaroop/byte'</span>, <span class="string">'/home/swaroop/bin'</span>]</span><br><span class="line"><span class="comment"># If you are using Windows, use source = [r'C:\Documents', r'D:\Work'] or something like that</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. The backup must be stored in a main backup directory</span></span><br><span class="line">target_dir = <span class="string">'/mnt/e/backup/'</span> <span class="comment"># Remember to change this to what you will be using</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. The files are backed up into a zip file.</span></span><br><span class="line"><span class="comment"># 4. The current day is the name of the subdirectory in the main directory</span></span><br><span class="line">today = target_dir + time.strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line"><span class="comment"># The current time is the name of the zip archive</span></span><br><span class="line">now = time.strftime(<span class="string">'%H%M%S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the subdirectory if it isn't already there</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(today):</span><br><span class="line">    os.mkdir(today) <span class="comment"># make directory</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Successfully created directory'</span>, today</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the zip file</span></span><br><span class="line">target = today + os.sep + now + <span class="string">'.zip'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. We use the zip command (in Unix/Linux) to put the files in a zip archive</span></span><br><span class="line">zip_command = <span class="string">"zip -qr '%s' %s"</span> % (target, <span class="string">' '</span>.join(source))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the backup</span></span><br><span class="line"><span class="keyword">if</span> os.system(zip_command) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Successful backup to'</span>, target</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Backup FAILED'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/backup_ver2.py" target="_blank" rel="external">code/backup_ver2.py</a>）</p>
<h3 id="输出-27">输出</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python backup_ver2.py</span><br><span class="line">Successfully created directory /mnt/e/<span class="operator"><span class="keyword">backup</span>/<span class="number">20041208</span></span><br><span class="line">Successful <span class="keyword">backup</span> <span class="keyword">to</span> /mnt/e/<span class="keyword">backup</span>/<span class="number">20041208</span>/<span class="number">080020.</span>zip</span><br><span class="line"></span><br><span class="line">$ python backup_ver2.py</span><br><span class="line">Successful <span class="keyword">backup</span> <span class="keyword">to</span> /mnt/e/<span class="keyword">backup</span>/<span class="number">20041208</span>/<span class="number">080428.</span>zip</span></span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-26">它如何工作</h3><p>两个程序的大部分是相同的。改变的部分主要是使用os.exists函数检验在主备份目录中是否有以当前日期作为名称的目录。如果没有，我们使用os.mkdir函数创建。</p>
<p>注意os.sep变量的用法——这会根据你的操作系统给出目录分隔符，即在Linux、Unix下它是’/‘，在Windows下它是’\‘，而在Mac OS下它是’:’。使用os.sep而非直接使用字符，会使我们的程序具有移植性，可以在上述这些系统下工作。</p>
<h3 id="版本三">版本三</h3><p>第二个版本在我做较多备份的时候还工作得不错，但是如果有极多备份的时候，我发现要区分每个备份是干什么的，会变得十分困难！例如，我可能对程序或者演讲稿做了一些重要的改变，于是我想要把这些改变与zip归档的名称联系起来。这可以通过在zip归档名上附带一个用户提供的注释来方便地实现。</p>
<p><strong>例10.3 备份脚本——版本三（不工作！）</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: backup_ver3.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. The files and directories to be backed up are specified in a list.</span></span><br><span class="line">source = [<span class="string">'/home/swaroop/byte'</span>, <span class="string">'/home/swaroop/bin'</span>]</span><br><span class="line"><span class="comment"># If you are using Windows, use source = [r'C:\Documents', r'D:\Work'] or something like that</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. The backup must be stored in a main backup directory</span></span><br><span class="line">target_dir = <span class="string">'/mnt/e/backup/'</span> <span class="comment"># Remember to change this to what you will be using</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. The files are backed up into a zip file.</span></span><br><span class="line"><span class="comment"># 4. The current day is the name of the subdirectory in the main directory</span></span><br><span class="line">today = target_dir + time.strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line"><span class="comment"># The current time is the name of the zip archive</span></span><br><span class="line">now = time.strftime(<span class="string">'%H%M%S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Take a comment from the user to create the name of the zip file</span></span><br><span class="line">comment = raw_input(<span class="string">'Enter a comment --&gt; '</span>)</span><br><span class="line"><span class="keyword">if</span> len(comment) == <span class="number">0</span>: <span class="comment"># check if a comment was entered</span></span><br><span class="line">    target = today + os.sep + now + <span class="string">'.zip'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    target = today + os.sep + now + <span class="string">'_'</span> +</span><br><span class="line">        comment.replace(<span class="string">' '</span>, <span class="string">'_'</span>) + <span class="string">'.zip'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the subdirectory if it isn't already there</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(today):</span><br><span class="line">    os.mkdir(today) <span class="comment"># make directory</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Successfully created directory'</span>, today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. We use the zip command (in Unix/Linux) to put the files in a zip archive</span></span><br><span class="line">zip_command = <span class="string">"zip -qr '%s' %s"</span> % (target, <span class="string">' '</span>.join(source))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the backup</span></span><br><span class="line"><span class="keyword">if</span> os.system(zip_command) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Successful backup to'</span>, target</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Backup FAILED'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/backup_ver3.py" target="_blank" rel="external">code/backup_ver3.py</a>）</p>
<h3 id="输出-28">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python backup_ver3<span class="class">.py</span></span><br><span class="line">File <span class="string">"backup_ver3.py"</span>, line <span class="number">25</span></span><br><span class="line">target = today + os<span class="class">.sep</span> + now + <span class="string">'_'</span> +</span><br><span class="line">                                ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<h3 id="它如何（不）工作">它如何（不）工作</h3><p>这个程序不工作！Python说有一个语法错误，这意味着脚本不满足Python可以识别的结构。当我们观察Python给出的错误的时候，它也告诉了我们它检测出错误的位置。所以我们从那行开始 调试 我们的程序。</p>
<p>通过仔细的观察，我们发现一个逻辑行被分成了两个物理行，但是我们并没有指明这两个物理行属于同一逻辑行。基本上，Python发现加法操作符（＋）在那一逻辑行没有任何操作数，因此它不知道该如何继续。记住我们可以使用物理行尾的反斜杠来表示逻辑行在下一物理行继续。所以，我们修正了程序。这被称为修订。</p>
<h3 id="版本四">版本四</h3><p><strong>例10.4 备份脚本——版本四</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: backup_ver4.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. The files and directories to be backed up are specified in a list.</span></span><br><span class="line">source = [<span class="string">'/home/swaroop/byte'</span>, <span class="string">'/home/swaroop/bin'</span>]</span><br><span class="line"><span class="comment"># If you are using Windows, use source = [r'C:\Documents', r'D:\Work'] or something like that</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. The backup must be stored in a main backup directory</span></span><br><span class="line">target_dir = <span class="string">'/mnt/e/backup/'</span> <span class="comment"># Remember to change this to what you will be using</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. The files are backed up into a zip file.</span></span><br><span class="line"><span class="comment"># 4. The current day is the name of the subdirectory in the main directory</span></span><br><span class="line">today = target_dir + time.strftime(<span class="string">'%Y%m%d'</span>)</span><br><span class="line"><span class="comment"># The current time is the name of the zip archive</span></span><br><span class="line">now = time.strftime(<span class="string">'%H%M%S'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Take a comment from the user to create the name of the zip file</span></span><br><span class="line">comment = raw_input(<span class="string">'Enter a comment --&gt; '</span>)</span><br><span class="line"><span class="keyword">if</span> len(comment) == <span class="number">0</span>: <span class="comment"># check if a comment was entered</span></span><br><span class="line">    target = today + os.sep + now + <span class="string">'.zip'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    target = today + os.sep + now + <span class="string">'_'</span> + \</span><br><span class="line">        comment.replace(<span class="string">' '</span>, <span class="string">'_'</span>) + <span class="string">'.zip'</span></span><br><span class="line">    <span class="comment"># Notice the backslash!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the subdirectory if it isn't already there</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(today):</span><br><span class="line">    os.mkdir(today) <span class="comment"># make directory</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Successfully created directory'</span>, today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. We use the zip command (in Unix/Linux) to put the files in a zip archive</span></span><br><span class="line">zip_command = <span class="string">"zip -qr '%s' %s"</span> % (target, <span class="string">' '</span>.join(source))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the backup</span></span><br><span class="line"><span class="keyword">if</span> os.system(zip_command) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Successful backup to'</span>, target</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Backup FAILED'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/backup_ver4.py" target="_blank" rel="external">code/backup_ver4.py</a>）</p>
<h3 id="输出-29">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ python backup_ver4<span class="class">.py</span></span><br><span class="line">Enter <span class="tag">a</span> comment --&gt; added new examples</span><br><span class="line">Successful backup to /mnt/e/backup/<span class="number">20041208</span>/<span class="number">082156</span>_added_new_examples<span class="class">.zip</span></span><br><span class="line"></span><br><span class="line">$ python backup_ver4<span class="class">.py</span></span><br><span class="line">Enter <span class="tag">a</span> comment --&gt;</span><br><span class="line">Successful backup to /mnt/e/backup/<span class="number">20041208</span>/<span class="number">082316</span>.zip</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-27">它如何工作</h3><p>这个程序现在工作了！让我们看一下版本三中作出的实质性改进。我们使用raw_input函数得到用户的注释，然后通过len函数找出输入的长度以检验用户是否确实输入了什么东西。如果用户只是按了回车（比如这只是一个惯例备份，没有做什么特别的修改），那么我们就如之前那样继续操作。</p>
<p>然而，如果提供了注释，那么它会被附加到zip归档名，就在.zip扩展名之前。注意我们把注释中的空格替换成下划线——这是因为处理这样的文件名要容易得多。</p>
<h3 id="进一步优化">进一步优化</h3><p>对于大多数用户来说，第四个版本是一个满意的工作脚本了，但是它仍然有进一步改进的空间。比如，你可以在程序中包含 交互 程度——你可以用-v选项来使你的程序更具交互性。</p>
<p>另一个可能的改进是使文件和目录能够通过命令行直接传递给脚本。我们可以通过sys.argv列表来获取它们，然后我们可以使用list类提供的extend方法把它们加到source列表中去。</p>
<p>我还希望有的一个优化是使用tar命令替代zip命令。这样做的一个优势是在你结合使用tar和gzip命令的时候，备份会更快更小。如果你想要在Windows中使用这些归档，WinZip也能方便地处理这些.tar.gz文件。tar命令在大多数Linux/Unix系统中都是默认可用的。Windows用户也可以下载安装它。</p>
<p>命令字符串现在将称为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar = <span class="string">'tar -cvzf %s %s -X /home/swaroop/excludes.txt'</span> % (target, <span class="string">' '</span>.join(srcdir))</span><br></pre></td></tr></table></figure>
<p>选项解释如下：</p>
<ul>
<li><p>-c表示创建一个归档。</p>
</li>
<li><p>-v表示交互，即命令更具交互性。</p>
</li>
<li><p>-z表示使用gzip滤波器。</p>
</li>
<li><p>-f表示强迫创建归档，即如果已经有一个同名文件，它会被替换。</p>
</li>
<li><p>-X表示含在指定文件名列表中的文件会被排除在备份之外。例如，你可以在文件中指定*~，从而不让备份包括所有以~结尾的文件。</p>
</li>
</ul>
<blockquote>
<p><strong>重要</strong></p>
<p>最理想的创建这些归档的方法是分别使用zipfile和tarfile。它们是Python标准库的一部分，可以供你使用。使用这些库就避免了使用os.system这个不推荐使用的函数，它容易引发严重的错误。<br>然而，我在本节中使用os.system的方法来创建备份，这纯粹是为了教学的需要。这样的话，例子就可以简单到让每个人都能够理解，同时也已经足够用了。</p>
</blockquote>
<h2 id="软件开发过程">软件开发过程</h2><p>现在，我们已经走过了编写一个软件的各个环节。这些环节可以概括如下：</p>
<ol>
<li>什么（分析）</li>
<li>如何（设计）</li>
<li>编写（实施）</li>
<li>测试（测试与调试）</li>
<li>使用（实施或开发）</li>
<li>维护（优化）</li>
</ol>
<blockquote>
<p><strong>重要</strong></p>
<p>我们创建这个备份脚本的过程是编写程序的推荐方法——进行分析与设计。开始时实施一个简单的版本。对它进行测试与调试。使用它以确信它如预期那样地工作。再增加任何你想要的特性，根据需要一次次重复这个编写－测试－使用的周期。记住“软件是长出来的，而不是建造的”。</p>
</blockquote>
<h2 id="概括-9">概括</h2><p>我们已经学习如何创建我们自己的Python程序/脚本，以及在编写这个程序中所设计到的不同的状态。你可以发现它们在创建你自己的程序的时候会十分有用，让你对Python以及解决问题都变得更加得心应手。</p>
<p>接下来，我们将讨论面向对象的编程。</p>
<h1 id="面向对象的编程">面向对象的编程</h1><h2 id="简介-7">简介</h2><p>到目前为止，在我们的程序中，我们都是根据操作数据的函数或语句块来设计程序的。这被称为 面向过程的 编程。还有一种把数据和功能结合起来，用称为对象的东西包裹起来组织程序的方法。这种方法称为 面向对象的 编程理念。在大多数时候你可以使用过程性编程，但是有些时候当你想要编写大型程序或是寻求一个更加合适的解决方案的时候，你就得使用面向对象的编程技术。</p>
<p>类和对象是面向对象编程的两个主要方面。类创建一个新类型，而对象这个类的 实例 。这类似于你有一个int类型的变量，这存储整数的变量是int类的实例（对象）。</p>
<blockquote>
<p><strong>给C/C++/Java/C#程序员的注释</strong> </p>
<p>注意，即便是整数也被作为对象（属于int类）。这和C++、Java（1.5版之前）把整数纯粹作为类型是不同的。通过help(int)了解更多这个类的详情。 C#和Java 1.5程序员会熟悉这个概念，因为它类似与 封装与解封装 的概念。</p>
</blockquote>
<p>对象可以使用普通的 属于 对象的变量存储数据。属于一个对象或类的变量被称为域。对象也可以使用 属于 类的函数来具有功能。这样的函数被称为类的方法。这些术语帮助我们把它们与孤立的函数和变量区分开来。域和方法可以合称为类的属性。</p>
<p>域有两种类型——属于每个实例/类的对象或属于类本身。它们分别被称为实例变量和类变量。</p>
<p>类使用class关键字创建。类的域和方法被列在一个缩进块中。</p>
<h2 id="self">self</h2><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，但是在调用这个方法的时候你不为这个参数赋值，Python会提供这个值。这个特别的变量指对象本身，按照惯例它的名称是self。</p>
<p>虽然你可以给这个参数任何名称，但是 强烈建议 你使用self这个名称——其他名称都是不赞成你使用的。使用一个标准的名称有很多优点——你的程序读者可以迅速识别它，如果使用self的话，还有些IDE（集成开发环境）也可以帮助你。</p>
<blockquote>
<p><strong>给C++/Java/C#程序员的注释</strong> </p>
<p>Python中的self等价于C++中的self指针和Java、C#中的this参考。</p>
</blockquote>
<p>你一定很奇怪Python如何给self赋值以及为何你不需要给它赋值。举一个例子会使此变得清晰。假如你有一个类称为MyClass和这个类的一个实例MyObject。当你调用这个对象的方法MyObject.method(arg1, arg2)的时候，这会由Python自动转为MyClass.method(MyObject, arg1, arg2)——这就是self的原理了。</p>
<p>这也意味着如果你有一个不需要参数的方法，你还是得给这个方法定义一个self参数。</p>
<h2 id="类">类</h2><p>一个尽可能简单的类如下面这个例子所示。</p>
<h3 id="创建一个类">创建一个类</h3><p><strong>例11.1 创建一个类</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: simplestclass.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># An empty block</span></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"><span class="keyword">print</span> p</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/simplestclass.py" target="_blank" rel="external">code/simplestclass.py</a>）</p>
<h3 id="输出-30">输出</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python simplestclass.py</span><br><span class="line">&lt;__main__.<span class="keyword">Person</span> instance at 0xf6fcb18c&gt;</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-28">它如何工作</h3><p>我们使用class语句后跟类名，创建了一个新的类。这后面跟着一个缩进的语句块形成类体。在这个例子中，我们使用了一个空白块，它由pass语句表示。</p>
<p>接下来，我们使用类名后跟一对圆括号来创建一个对象/实例。（我们将在下面的章节中学习更多的如何创建实例的方法）。为了验证，我们简单地打印了这个变量的类型。它告诉我们我们已经在<strong>main</strong>模块中有了一个Person类的实例。</p>
<p>可以注意到存储对象的计算机内存地址也打印了出来。这个地址在你的计算机上会是另外一个值，因为Python可以在任何空位存储对象。</p>
<h2 id="对象的方法">对象的方法</h2><p>我们已经讨论了类/对象可以拥有像函数一样的方法，这些方法与函数的区别只是一个额外的self变量。现在我们来学习一个例子。</p>
<h3 id="使用对象的方法">使用对象的方法</h3><p><strong>例11.2 使用对象的方法</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: method.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hello, how are you?'</span></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.sayHi()</span><br><span class="line"></span><br><span class="line"><span class="comment"># This short example can also be written as Person().sayHi()</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/method.py" target="_blank" rel="external">code/method.py</a>）</p>
<h3 id="输出-31">输出</h3><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">method</span>.py</span><br><span class="line"><span class="type">Hello</span>, how are you?</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-29">它如何工作</h3><p>这里我们看到了self的用法。注意sayHi方法没有任何参数，但仍然在函数定义时有self。</p>
<h2 id="init方法"><strong>init</strong>方法</h2><p>在Python的类中有很多方法的名字有特殊的重要意义。现在我们将学习__init__方法的意义。</p>
<p>__init__方法在类的一个对象被建立时，马上运行。这个方法可以用来对你的对象做一些你希望的 初始化 。注意，这个名称的开始和结尾都是双下划线。</p>
<h3 id="使用init方法">使用<strong>init</strong>方法</h3><p><strong>例11.3 使用__init__方法</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: class_init.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hello, my name is'</span>, self.name</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">'Swaroop'</span>)</span><br><span class="line">p.sayHi()</span><br><span class="line"></span><br><span class="line"><span class="comment"># This short example can also be written as Person('Swaroop').sayHi()</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/class_init.py" target="_blank" rel="external">code/class_init.py</a>）</p>
<h3 id="输出-32">输出</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python class_init.py</span><br><span class="line">Hello, <span class="keyword">my</span> <span class="property">name</span> <span class="keyword">is</span> Swaroop</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-30">它如何工作</h3><p>这里，我们把__init__方法定义为取一个参数name（以及普通的参数self）。在这个__init__里，我们只是创建一个新的域，也称为name。注意它们是两个不同的变量，尽管它们有相同的名字。点号使我们能够区分它们。</p>
<p>最重要的是，我们没有专门调用__init__方法，只是在创建一个类的新实例的时候，把参数包括在圆括号内跟在类名后面，从而传递给__init__方法。这是这种方法的重要之处。</p>
<p>现在，我们能够在我们的方法中使用self.name域。这在sayHi方法中得到了验证。</p>
<blockquote>
<p><strong>给C++/Java/C#程序员的注释</strong> </p>
<p><strong>init</strong>方法类似于C++、C#和Java中的 constructor 。</p>
</blockquote>
<h2 id="类与对象的方法">类与对象的方法</h2><p>我们已经讨论了类与对象的功能部分，现在我们来看一下它的数据部分。事实上，它们只是与类和对象的名称空间 绑定 的普通变量，即这些名称只在这些类与对象的前提下有效。</p>
<p>有两种类型的 域 ——类的变量和对象的变量，它们根据是类还是对象 拥有 这个变量而区分。</p>
<p>类的变量 由一个类的所有对象（实例）共享使用。只有一个类变量的拷贝，所以当某个对象对类的变量做了改动的时候，这个改动会反映到所有其他的实例上。</p>
<p>对象的变量 由类的每个对象/实例拥有。因此每个对象有自己对这个域的一份拷贝，即它们不是共享的，在同一个类的不同实例中，虽然对象的变量有相同的名称，但是是互不相关的。通过一个例子会使这个易于理解。</p>
<h3 id="使用类与对象的变量">使用类与对象的变量</h3><p><strong>例11.4 使用类与对象的变量</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: objvar.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="string">'''Represents a person.'''</span></span><br><span class="line">    population = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">'''Initializes the person's data.'''</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initializing %s)'</span> % self.name</span><br><span class="line"></span><br><span class="line">        <span class="comment"># When this person is created, he/she</span></span><br><span class="line">        <span class="comment"># adds to the population</span></span><br><span class="line">        Person.population += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''I am dying.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%s says bye.'</span> % self.name</span><br><span class="line"></span><br><span class="line">        Person.population -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> Person.population == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'I am the last one.'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'There are still %d people left.'</span> % Person.population</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Greeting by the person.</span><br><span class="line"></span><br><span class="line">        Really, that's all it does.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Hi, my name is %s.'</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">howMany</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Prints the current population.'''</span></span><br><span class="line">        <span class="keyword">if</span> Person.population == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'I am the only person here.'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'We have %d persons here.'</span> % Person.population</span><br><span class="line"></span><br><span class="line">swaroop = Person(<span class="string">'Swaroop'</span>)</span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br><span class="line"></span><br><span class="line">kalam = Person(<span class="string">'Abdul Kalam'</span>)</span><br><span class="line">kalam.sayHi()</span><br><span class="line">kalam.howMany()</span><br><span class="line"></span><br><span class="line">swaroop.sayHi()</span><br><span class="line">swaroop.howMany()</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/objvar.py" target="_blank" rel="external">code/objvar.py</a>）</p>
<h3 id="输出-33">输出</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python objvar.py</span><br><span class="line">(Initializing Swaroop)</span><br><span class="line">Hi, my name <span class="keyword">is</span> Swaroop.</span><br><span class="line">I am the only <span class="keyword">person</span> here.</span><br><span class="line">(Initializing Abdul Kalam)</span><br><span class="line">Hi, my name <span class="keyword">is</span> Abdul Kalam.</span><br><span class="line">We have 2 persons here.</span><br><span class="line">Hi, my name <span class="keyword">is</span> Swaroop.</span><br><span class="line">We have 2 persons here.</span><br><span class="line">Abdul Kalam says bye.</span><br><span class="line">There <span class="keyword">are</span> still 1 people left.</span><br><span class="line">Swaroop says bye.</span><br><span class="line">I am the last one.</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-31">它如何工作</h3><p>这是一个很长的例子，但是它有助于说明类与对象的变量的本质。这里，population属于Person类，因此是一个类的变量。name变量属于对象（它使用self赋值）因此是对象的变量。</p>
<p>观察可以发现<strong>init</strong>方法用一个名字来初始化Person实例。在这个方法中，我们让population增加1，这是因为我们增加了一个人。同样可以发现，self.name的值根据每个对象指定，这表明了它作为对象的变量的本质。</p>
<p>记住，你只能使用self变量来参考同一个对象的变量和方法。这被称为 属性参考 。</p>
<p>在这个程序中，我们还看到docstring对于类和方法同样有用。我们可以在运行时使用Person.<strong>doc</strong>和Person.sayHi.<strong>doc</strong>来分别访问类与方法的文档字符串。</p>
<p>就如同<strong>init</strong>方法一样，还有一个特殊的方法<strong>del</strong>，它在对象消逝的时候被调用。对象消逝即对象不再被使用，它所占用的内存将返回给系统作它用。在这个方法里面，我们只是简单地把Person.population减1。</p>
<p>当对象不再被使用时，<strong>del</strong>方法运行，但是很难保证这个方法究竟在 什么时候 运行。如果你想要指明它的运行，你就得使用del语句，就如同我们在以前的例子中使用的那样。</p>
<blockquote>
<p><strong>给C++/Java/C#程序员的注释</strong> </p>
<p>Python中所有的类成员（包括数据成员）都是 公共的 ，所有的方法都是 有效的 。<br>只有一个例外：如果你使用的数据成员名称以 双下划线前缀 比如<strong>privatevar，Python的名称管理体系会有效地把它作为私有变量。<br>这样就有一个惯例，如果某个变量只想在类或对象中使用，就应该以单下划线前缀。而其他的名称都将作为公共的，可以被其他类/对象使用。记住这只是一个惯例，并不是Python所要求的（与双下划线前缀不同）。<br>同样，注意</strong>del__方法与 destructor 的概念类似。</p>
</blockquote>
<h2 id="继承">继承</h2><p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过 继承 机制。继承完全可以理解成类之间的 类型和子类型 关系。</p>
<p>假设你想要写一个程序来记录学校之中的教师和学生情况。他们有一些共同属性，比如姓名、年龄和地址。他们也有专有的属性，比如教师的薪水、课程和假期，学生的成绩和学费。</p>
<p>你可以为教师和学生建立两个独立的类来处理它们，但是这样做的话，如果要增加一个新的共有属性，就意味着要在这两个独立的类中都增加这个属性。这很快就会显得不实用。</p>
<p>一个比较好的方法是创建一个共同的类称为SchoolMember然后让教师和学生的类 继承 这个共同的类。即它们都是这个类型（类）的子类型，然后我们再为这些子类型添加专有的属性。</p>
<p>使用这种方法有很多优点。如果我们增加/改变了SchoolMember中的任何功能，它会自动地反映到子类型之中。例如，你要为教师和学生都增加一个新的身份证域，那么你只需简单地把它加到SchoolMember类中。然而，在一个子类型之中做的改动不会影响到别的子类型。另外一个优点是你可以把教师和学生对象都作为SchoolMember对象来使用，这在某些场合特别有用，比如统计学校成员的人数。一个子类型在任何需要父类型的场合可以被替换成父类型，即对象可以被视作是父类的实例，这种现象被称为多态现象。</p>
<p>另外，我们会发现在 重用 父类的代码的时候，我们无需在不同的类中重复它。而如果我们使用独立的类的话，我们就不得不这么做了。</p>
<p>在上述的场合中，SchoolMember类被称为 基本类 或 超类 。而Teacher和Student类被称为 导出类 或 子类 。</p>
<p>现在，我们将学习一个例子程序。</p>
<h3 id="使用继承">使用继承</h3><p><strong>例11.5 使用继承</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: inherit.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolMember</span>:</span></span><br><span class="line">    <span class="string">'''Represents any school member.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized SchoolMember: %s)'</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''Tell my details.'''</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Name:"%s" Age:"%s"'</span> % (self.name, self.age),</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(SchoolMember)</span>:</span></span><br><span class="line">    <span class="string">'''Represents a teacher.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, salary)</span>:</span></span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.salary = salary</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized Teacher: %s)'</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Salary: "%d"'</span> % self.salary</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(SchoolMember)</span>:</span></span><br><span class="line">    <span class="string">'''Represents a student.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, marks)</span>:</span></span><br><span class="line">        SchoolMember.__init__(self, name, age)</span><br><span class="line">        self.marks = marks</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'(Initialized Student: %s)'</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell</span><span class="params">(self)</span>:</span></span><br><span class="line">        SchoolMember.tell(self)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Marks: "%d"'</span> % self.marks</span><br><span class="line"></span><br><span class="line">t = Teacher(<span class="string">'Mrs. Shrividya'</span>, <span class="number">40</span>, <span class="number">30000</span>)</span><br><span class="line">s = Student(<span class="string">'Swaroop'</span>, <span class="number">22</span>, <span class="number">75</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="comment"># prints a blank line</span></span><br><span class="line"></span><br><span class="line">members = [t, s]</span><br><span class="line"><span class="keyword">for</span> member <span class="keyword">in</span> members:</span><br><span class="line">    member.tell() <span class="comment"># works for both Teachers and Students</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/inherit.py" target="_blank" rel="external">code/inherit.py</a>）</p>
<h3 id="输出-34">输出</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python inherit.py</span><br><span class="line">(Initialized <span class="string">SchoolMember:</span> Mrs. Shrividya)</span><br><span class="line">(Initialized <span class="string">Teacher:</span> Mrs. Shrividya)</span><br><span class="line">(Initialized <span class="string">SchoolMember:</span> Swaroop)</span><br><span class="line">(Initialized <span class="string">Student:</span> Swaroop)</span><br><span class="line"><span class="label"></span><br><span class="line">Name:</span><span class="string">"Mrs. Shrividya"</span> <span class="string">Age:</span><span class="string">"40"</span> <span class="string">Salary:</span> <span class="string">"30000"</span></span><br><span class="line"><span class="string">Name:</span><span class="string">"Swaroop"</span> <span class="string">Age:</span><span class="string">"22"</span> <span class="string">Marks:</span> <span class="string">"75"</span></span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-32">它如何工作</h3><p>为了使用继承，我们把基本类的名称作为一个元组跟在定义类时的类名称之后。然后，我们注意到基本类的<strong>init</strong>方法专门使用self变量调用，这样我们就可以初始化对象的基本类部分。这一点十分重要——Python不会自动调用基本类的constructor，你得亲自专门调用它。</p>
<p>我们还观察到我们在方法调用之前加上类名称前缀，然后把self变量及其他参数传递给它。</p>
<p>注意，在我们使用SchoolMember类的tell方法的时候，我们把Teacher和Student的实例仅仅作为SchoolMember的实例。</p>
<p>另外，在这个例子中，我们调用了子类型的tell方法，而不是SchoolMember类的tell方法。可以这样来理解，Python总是首先查找对应类型的方法，在这个例子中就是如此。如果它不能在导出类中找到对应的方法，它才开始到基本类中逐个查找。基本类是在类定义的时候，在元组之中指明的。</p>
<p>一个术语的注释——如果在继承元组中列了一个以上的类，那么它就被称作 多重继承 。</p>
<h2 id="概括-10">概括</h2><p>我们已经研究了类和对象的多个内容以及与它们相关的多个术语。通过本章，你已经了解了面向对象的编程的优点和缺陷。Python是一个高度面向对象的语言，理解这些概念会在将来有助于你进一步深入学习Python。</p>
<p>接下来，我们将学习如何处理输入/输出已经如何用Python访问文件。</p>
<h1 id="输入&amp;输出">输入&amp;输出</h1><p>在很多时候，你会想要让你的程序与用户（可能是你自己）交互。你会从用户那里得到输入，然后打印一些结果。我们可以分别使用raw_input和print语句来完成这些功能。对于输出，你也可以使用多种多样的str（字符串）类。例如，你能够使用rjust方法来得到一个按一定宽度右对齐的字符串。利用help(str)获得更多详情。</p>
<p>另一个常用的输入/输出类型是处理文件。创建、读和写文件的能力是许多程序所必需的，我们将会在这章探索如何实现这些功能。</p>
<h2 id="文件">文件</h2><p>你可以通过创建一个file类的对象来打开一个文件，分别使用file类的read、readline或write方法来恰当地读写文件。对文件的读写能力依赖于你在打开文件时指定的模式。最后，当你完成对文件的操作的时候，你调用close方法来告诉Python我们完成了对文件的使用。</p>
<h3 id="使用文件">使用文件</h3><p><strong>例12.1 使用文件</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: using_file.py</span></span><br><span class="line"></span><br><span class="line">poem = <span class="string">'''\</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line">if you wanna make your work also fun:</span><br><span class="line">        use Python!</span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line">f = file(<span class="string">'poem.txt'</span>, <span class="string">'w'</span>) <span class="comment"># open for 'w'riting</span></span><br><span class="line">f.write(poem) <span class="comment"># write text to file</span></span><br><span class="line">f.close() <span class="comment"># close the file</span></span><br><span class="line"></span><br><span class="line">f = file(<span class="string">'poem.txt'</span>)</span><br><span class="line"><span class="comment"># if no mode is specified, 'r'ead mode is assumed by default</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">if</span> len(line) == <span class="number">0</span>: <span class="comment"># Zero length indicates EOF</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> line,</span><br><span class="line">    <span class="comment"># Notice comma to avoid automatic newline added by Python</span></span><br><span class="line">f.close() <span class="comment"># close the file</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/using_file.py" target="_blank" rel="external">code/using_file.py</a>）</p>
<h3 id="输出-35">输出</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python using_file.py</span><br><span class="line">Programming <span class="keyword">is</span> <span class="function"><span class="keyword">fun</span></span></span><br><span class="line">When the work <span class="keyword">is</span> done</span><br><span class="line"><span class="keyword">if</span> you wanna make your work also <span class="function"><span class="keyword">fun</span>:</span></span><br><span class="line">        use Python!</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-33">它如何工作</h3><p>首先，我们通过指明我们希望打开的文件和模式来创建一个file类的实例。模式可以为读模式（’r’）、写模式（’w’）或追加模式（’a’）。事实上还有多得多的模式可以使用，你可以使用help(file)来了解它们的详情。</p>
<p>我们首先用写模式打开文件，然后使用file类的write方法来写文件，最后我们用close关闭这个文件。</p>
<p>接下来，我们再一次打开同一个文件来读文件。如果我们没有指定模式，读模式会作为默认的模式。在一个循环中，我们使用readline方法读文件的每一行。这个方法返回包括行末换行符的一个完整行。所以，当一个 空的 字符串被返回的时候，即表示文件末已经到达了，于是我们停止循环。</p>
<p>注意，因为从文件读到的内容已经以换行符结尾，所以我们在print语句上使用逗号来消除自动换行。最后，我们用close关闭这个文件。</p>
<p>现在，来看一下poem.txt文件的内容来验证程序确实工作正常了。</p>
<h2 id="储存器">储存器</h2><p>Python提供一个标准的模块，称为pickle。使用它你可以在一个文件中储存任何Python对象，之后你又可以把它完整无缺地取出来。这被称为 持久地 储存对象。</p>
<p>还有另一个模块称为cPickle，它的功能和pickle模块完全相同，只不过它是用C语言编写的，因此要快得多（比pickle快1000倍）。你可以使用它们中的任一个，而我们在这里将使用cPickle模块。记住，我们把这两个模块都简称为pickle模块。</p>
<h3 id="储存与取储存">储存与取储存</h3><p><strong>例12.2 储存与取储存</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: pickling.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cPickle <span class="keyword">as</span> p</span><br><span class="line"><span class="comment">#import pickle as p</span></span><br><span class="line"></span><br><span class="line">shoplistfile = <span class="string">'shoplist.data'</span></span><br><span class="line"><span class="comment"># the name of the file where we will store the object</span></span><br><span class="line"></span><br><span class="line">shoplist = [<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write to the file</span></span><br><span class="line">f = file(shoplistfile, <span class="string">'w'</span>)</span><br><span class="line">p.dump(shoplist, f) <span class="comment"># dump the object to a file</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> shoplist <span class="comment"># remove the shoplist</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read back from the storage</span></span><br><span class="line">f = file(shoplistfile)</span><br><span class="line">storedlist = p.load(f)</span><br><span class="line"><span class="keyword">print</span> storedlist</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/pickling.py" target="_blank" rel="external">code/pickling.py</a>）</p>
<h3 id="输出-36">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python pickling<span class="class">.py</span></span><br><span class="line">[<span class="string">'apple'</span>, <span class="string">'mango'</span>, <span class="string">'carrot'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-34">它如何工作</h3><p>首先，请注意我们使用了import..as语法。这是一种便利方法，以便于我们可以使用更短的模块名称。在这个例子中，它还让我们能够通过简单地改变一行就切换到另一个模块（cPickle或者pickle）！在程序的其余部分的时候，我们简单地把这个模块称为p。</p>
<p>为了在文件里储存一个对象，首先以写模式打开一个file对象，然后调用储存器模块的dump函数，把对象储存到打开的文件中。这个过程称为 储存 。</p>
<p>接下来，我们使用pickle模块的load函数的返回来取回对象。这个过程称为 取储存 。</p>
<h2 id="概括-11">概括</h2><p>我们已经讨论了多种类型的输入/输出，及文件处理和使用储存器模块。</p>
<p>接下来，我们将探索异常的概念。</p>
<h1 id="异常">异常</h1><p>当你的程序中出现某些 异常的 状况的时候，异常就发生了。例如，当你想要读某个文件的时候，而那个文件不存在。或者在程序运行的时候，你不小心把它删除了。上述这些情况可以使用异常来处理。</p>
<p>假如你的程序中有一些无效的语句，会怎么样呢？Python会引发并告诉你那里有一个错误，从而处理这样的情况。</p>
<h2 id="错误">错误</h2><p>考虑一个简单的print语句。假如我们把print误拼为Print，注意大写，这样Python会 引发 一个语法错误。 </p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; <span class="constant">Print</span> <span class="string">'Hello World'</span></span><br><span class="line">    <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">      <span class="constant">Print</span> <span class="string">'Hello World'</span></span><br><span class="line">                        ^</span><br><span class="line"><span class="constant">SyntaxError</span><span class="symbol">:</span> invalid syntax</span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; print <span class="string">'Hello World'</span></span><br><span class="line"><span class="constant">Hello</span> <span class="constant">World</span></span><br></pre></td></tr></table></figure>
<p>我们可以观察到有一个SyntaxError被引发，并且检测到的错误位置也被打印了出来。这是这个错误的 错误处理器 所做的工作。</p>
<h2 id="try-except">try..except</h2><p>我们尝试读取用户的一段输入。按Ctrl-d，看一下会发生什么。</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = raw_input(<span class="attribute">'Enter</span> something <span class="comment">--&gt; ')</span></span><br><span class="line">Enter something <span class="comment">--&gt; Traceback (most recent call last):</span></span><br><span class="line">  <span class="keyword">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">EOFError</span><br></pre></td></tr></table></figure>
<p>Python引发了一个称为EOFError的错误，这个错误基本上意味着它发现一个不期望的 文件尾 （由Ctrl-d表示）</p>
<p>接下来，我们将学习如何处理这样的错误。</p>
<h3 id="处理异常">处理异常</h3><p>我们可以使用try..except语句来处理异常。我们把通常的语句放在try-块中，而把我们的错误处理语句放在except-块中。</p>
<p><strong>例13.1 处理异常</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: try_except.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = raw_input(<span class="string">'Enter something --&gt; '</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nWhy did you do an EOF on me?'</span></span><br><span class="line">    sys.exit() <span class="comment"># exit the program</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nSome error/exception occurred.'</span></span><br><span class="line">    <span class="comment"># here, we are not exiting the program</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Done'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/try_except.py" target="_blank" rel="external">code/try_except.py</a>）</p>
<h3 id="输出-37">输出</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> try_except.<span class="keyword">py</span></span><br><span class="line">Enter something --&gt;</span><br><span class="line">Why did you <span class="keyword">do</span> <span class="keyword">an</span> EOF <span class="keyword">on</span> <span class="keyword">me</span>?</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">python</span> try_except.<span class="keyword">py</span></span><br><span class="line">Enter something --&gt; Python <span class="keyword">is</span> exceptional!</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-35">它如何工作</h3><p>我们把所有可能引发错误的语句放在try块中，然后在except从句/块中处理所有的错误和异常。except从句可以专门处理单一的错误或异常，或者一组包括在圆括号内的错误/异常。如果没有给出错误或异常的名称，它会处理 所有的 错误和异常。对于每个try从句，至少都有一个相关联的except从句。</p>
<p>如果某个错误或异常没有被处理，默认的Python处理器就会被调用。它会终止程序的运行，并且打印一个消息，我们已经看到了这样的处理。</p>
<p>你还可以让try..catch块关联上一个else从句。当没有异常发生的时候，else从句将被执行。</p>
<p>我们还可以得到异常对象，从而获取更多有个这个异常的信息。这会在下一个例子中说明。</p>
<p>我们把所有可能引发错误的语句放在try块中，然后在except从句/块中处理所有的错误和异常。except从句可以专门处理单一的错误或异常，或者一组包括在圆括号内的错误/异常。如果没有给出错误或异常的名称，它会处理 所有的 错误和异常。对于每个try从句，至少都有一个相关联的except从句。</p>
<p>如果某个错误或异常没有被处理，默认的Python处理器就会被调用。它会终止程序的运行，并且打印一个消息，我们已经看到了这样的处理。</p>
<p>你还可以让try..catch块关联上一个else从句。当没有异常发生的时候，else从句将被执行。</p>
<p>我们还可以得到异常对象，从而获取更多有个这个异常的信息。这会在下一个例子中说明。</p>
<h2 id="引发异常">引发异常</h2><p>你可以使用raise语句 引发 异常。你还得指明错误/异常的名称和伴随异常 触发的 异常对象。你可以引发的错误或异常应该分别是一个Error或Exception类的直接或间接导出类。</p>
<h3 id="如何引发异常">如何引发异常</h3><p><strong>例13.2 如何引发异常</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: raising.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortInputException</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">'''A user-defined exception class.'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, length, atleast)</span>:</span></span><br><span class="line">        Exception.__init__(self)</span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    s = raw_input(<span class="string">'Enter something --&gt; '</span>)</span><br><span class="line">    <span class="keyword">if</span> len(s) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> ShortInputException(len(s), <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># Other work can continue as usual here</span></span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\nWhy did you do an EOF on me?'</span></span><br><span class="line"><span class="keyword">except</span> ShortInputException, x:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'ShortInputException: The input was of length %d, \</span><br><span class="line">          was expecting at least %d'</span> % (x.length, x.atleast)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'No exception was raised.'</span></span><br></pre></td></tr></table></figure>
<p>源文件（<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/raising.py" target="_blank" rel="external">code/raising.py</a>）</p>
<h3 id="输出-38">输出</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python raising.py</span><br><span class="line">Enter something <span class="comment">--&gt;</span></span><br><span class="line">Why did you <span class="built_in">do</span> <span class="operator">an</span> <span class="constant">EOF</span> <span class="command"><span class="keyword">on</span> <span class="title">me</span>?</span></span><br><span class="line"></span><br><span class="line">$ python raising.py</span><br><span class="line">Enter something <span class="comment">--&gt; ab</span></span><br><span class="line">ShortInputException: The input was <span class="operator">of</span> <span class="built_in">length</span> <span class="number">2</span>, was expecting <span class="keyword">at</span> least <span class="number">3</span></span><br><span class="line"></span><br><span class="line">$ python raising.py</span><br><span class="line">Enter something <span class="comment">--&gt; abc</span></span><br><span class="line">No exception was raised.</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-36">它如何工作</h3><p>这里，我们创建了我们自己的异常类型，其实我们可以使用任何预定义的异常/错误。这个新的异常类型是ShortInputException类。它有两个域——length是给定输入的长度，atleast则是程序期望的最小长度。</p>
<p>在except从句中，我们提供了错误类和用来表示错误/异常对象的变量。这与函数调用中的形参和实参概念类似。在这个特别的except从句中，我们使用异常对象的length和atleast域来为用户打印一个恰当的消息。</p>
<h2 id="try-finally">try..finally</h2><p>假如你在读一个文件的时候，希望在无论异常发生与否的情况下都关闭文件，该怎么做呢？这可以使用finally块来完成。注意，在一个try块下，你可以同时使用except从句和finally块。如果你要同时使用它们的话，需要把一个嵌入另外一个。</p>
<h3 id="使用finally">使用finally</h3><p><strong>例13.3 使用finally</strong></p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: finally.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = file(<span class="string">'poem.txt'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>: <span class="comment"># our usual file-reading idiom</span></span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="keyword">if</span> len(line) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">print</span> line,</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Cleaning up...closed the file'</span></span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/finally.py" target="_blank" rel="external">code/finally.py</a>）</p>
<h3 id="输出-39">输出</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python finally.py</span><br><span class="line">Programming <span class="keyword">is</span> fun</span><br><span class="line">When the work is done</span><br><span class="line">Cleaning up...closed the file</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"finally.py"</span>, line 12, in ?</span><br><span class="line">    time.sleep(2)</span><br><span class="line">KeyboardInterrupt</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-37">它如何工作</h3><p>我们进行通常的读文件工作，但是我有意在每打印一行之前用time.sleep方法暂停2秒钟。这样做的原因是让程序运行得慢一些（Python由于其本质通常运行得很快）。在程序运行的时候，按Ctrl-c中断/取消程序。</p>
<p>我们可以观察到KeyboardInterrupt异常被触发，程序退出。但是在程序退出之前，finally从句仍然被执行，把文件关闭</p>
<h2 id="概括-12">概括</h2><p>我们已经讨论了try..except和try..finally语句的用法。我们还学习了如何创建我们自己的异常类型和如何引发异常。</p>
<p>接下来，我们将探索Python标准库。</p>
<h1 id="Python标准库">Python标准库</h1><h2 id="第14章_Python标准库">第14章 Python标准库</h2><p>Python标准库是随Python附带安装的，它包含大量极其有用的模块。熟悉Python标准库是十分重要的，因为如果你熟悉这些库中的模块，那么你的大多数问题都可以简单快捷地使用它们来解决。</p>
<p>我们已经研究了一些这个库中的常用模块。你可以在Python附带安装的文档的“库参考”一节中了解Python标准库中所有模块的完整内容。</p>
<h2 id="sys模块">sys模块</h2><p>sys模块包含系统对应的功能。我们已经学习了sys.argv列表，它包含命令行参数。</p>
<h3 id="命令行参数">命令行参数</h3><p><strong>例14.1 使用sys.argv</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: cat.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readfile</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">'''Print a file to the standard output.'''</span></span><br><span class="line">    f = file(filename)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="keyword">if</span> len(line) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span> line, <span class="comment"># notice comma</span></span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Script starts from here</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &lt; <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'No action specified.'</span></span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>].startswith(<span class="string">'--'</span>):</span><br><span class="line">    option = sys.argv[<span class="number">1</span>][<span class="number">2</span>:]</span><br><span class="line">    <span class="comment"># fetch sys.argv[1] but without the first two characters</span></span><br><span class="line">    <span class="keyword">if</span> option == <span class="string">'version'</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Version 1.2'</span></span><br><span class="line">    <span class="keyword">elif</span> option == <span class="string">'help'</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'''\</span><br><span class="line">This program prints files to the standard output.</span><br><span class="line">Any number of files can be specified.</span><br><span class="line">Options include:</span><br><span class="line">  --version : Prints the version number</span><br><span class="line">  --help    : Display this help'''</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Unknown option.'</span></span><br><span class="line">    sys.exit()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">        readfile(filename)</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/cat.py" target="_blank" rel="external">code/cat.py</a>）</p>
<h3 id="输出-40">输出</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ python <span class="keyword">cat</span>.py</span><br><span class="line"><span class="keyword">No</span> action specified.</span><br><span class="line"></span><br><span class="line">$ python <span class="keyword">cat</span>.py --<span class="keyword">help</span></span><br><span class="line">This <span class="keyword">program</span> prints files to the standard output.</span><br><span class="line">Any number of files can be specified.</span><br><span class="line">Options <span class="keyword">include</span>:</span><br><span class="line">  --<span class="keyword">version</span> : Prints the <span class="keyword">version</span> number</span><br><span class="line">  --<span class="keyword">help</span>    : <span class="keyword">Display</span> this <span class="keyword">help</span></span><br><span class="line"></span><br><span class="line">$ python <span class="keyword">cat</span>.py --<span class="keyword">version</span></span><br><span class="line"><span class="keyword">Version</span> 1.2</span><br><span class="line"></span><br><span class="line">$ python <span class="keyword">cat</span>.py --nonsense</span><br><span class="line">Unknown option.</span><br><span class="line"></span><br><span class="line">$ python <span class="keyword">cat</span>.py poem.txt</span><br><span class="line">Programming is fun</span><br><span class="line">When the work is done</span><br><span class="line"><span class="keyword">if</span> you wanna make your work also fun:</span><br><span class="line">        <span class="keyword">use</span> Python!</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-38">它如何工作</h3><p>这个程序用来模范Linux/Unix用户熟悉的cat命令。你只需要指明某些文本文件的名字，这个程序会把它们打印输出。</p>
<p>在Python程序运行的时候，即不是在交互模式下，在sys.argv列表中总是至少有一个项目。它就是当前运行的程序名称，作为sys.argv[0]（由于Python从0开始计数）。其他的命令行参数在这个项目之后。</p>
<p>为了使这个程序对用户更加友好，我们提供了一些用户可以指定的选项来了解更多程序的内容。我们使用第一个参数来检验我们的程序是否被指定了选项。如果使用了—version选项，程序的版本号将被打印出来。类似地，如果指定了—help选项，我们提供一些关于程序的解释。我们使用sys.exit函数退出正在运行的程序。和以往一样，你可以看一下help(sys.exit)来了解更多详情。</p>
<p>如果没有指定任何选项，而是为程序提供文件名的话，它就简单地打印出每个文件地每一行，按照命令行中的顺序一个文件接着一个文件地打印。</p>
<p>顺便说一下，名称cat是 concatenate 的缩写，它基本上表明了程序的功能——它可以在输出打印一个文件或者把两个或两个以上文件连接/级连在一起打印。</p>
<h3 id="更多sys的内容">更多sys的内容</h3><p>sys.version字符串给你提供安装的Python的版本信息。sys.version_info元组则提供一个更简单的方法来使你的程序具备Python版本要求功能。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[swaroop<span class="variable">@localhost</span> code]<span class="variable">$ </span>python</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; import sys</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; sys.version</span><br><span class="line"><span class="string">'2.3.4 (#1, Oct 26 2004, 16:42:40) \n[GCC 3.4.2 20041017 (Red Hat 3.4.2-6.fc3)]'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; sys.version_info</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">'final'</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>对于有经验的程序员，sys模块中其他令人感兴趣的项目有sys.stdin、sys.stdout和sys.stderr它们分别对应你的程序的标准输入、标准输出和标准错误流。</p>
<h2 id="os模块">os模块</h2><p>这个模块包含普遍的操作系统功能。如果你希望你的程序能够与平台无关的话，这个模块是尤为重要的。即它允许一个程序在编写后不需要任何改动，也不会发生任何问题，就可以在Linux和Windows下运行。一个例子就是使用os.sep可以取代操作系统特定的路径分割符。</p>
<p>下面列出了一些在os模块中比较有用的部分。它们中的大多数都简单明了。</p>
<ul>
<li>os.name字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。</li>
<li>os.getcwd()函数得到当前工作目录，即当前Python脚本工作的目录路径。</li>
<li>os.getenv()和os.putenv()函数分别用来读取和设置环境变量。</li>
<li>os.listdir()返回指定目录下的所有文件和目录名。</li>
<li>os.remove()函数用来删除一个文件。</li>
<li>os.system()函数用来运行shell命令。</li>
<li>os.linesep字符串给出当前平台使用的行终止符。例如，Windows使用’\r\n’，Linux使用’\n’而Mac使用’\r’。</li>
<li>os.path.split()函数返回一个路径的目录名和文件名。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; os<span class="class">.path</span><span class="class">.split</span>(<span class="string">'/home/swaroop/byte/code/poem.txt'</span>)</span><br><span class="line">(<span class="string">'/home/swaroop/byte/code'</span>, <span class="string">'poem.txt'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>os.path.isfile()和os.path.isdir()函数分别检验给出的路径是一个文件还是目录。类似地，os.path.existe()函数用来检验给出的路径是否真地存在。</li>
</ul>
<p>你可以利用Python标准文档去探索更多有关这些函数和变量的详细知识。你也可以使用help(sys)等等。</p>
<h2 id="概括-13">概括</h2><p>我们已经学习了Python标准库中的sys模块和os模块的一部分功能。你应该利用Python标准文档去学习这两个模块以及其他模块的更多内容。</p>
<p>接下来，我们将要学习Python中剩余的几个方面的内容，从而使我们的Python课程更加 完整 。</p>
<h1 id="更多Python的内容">更多Python的内容</h1><p>到目前为止，我们已经学习了绝大多数常用的Python知识。在这一章中，我们将要学习另外一些方面的Python知识，从而使我们对Python的了解更加 完整 。</p>
<h2 id="特殊的方法">特殊的方法</h2><p>在类中有一些特殊的方法具有特殊的意义，比如<strong>init</strong>和<strong>del</strong>方法，它们的重要性我们已经学习过了。</p>
<p>一般说来，特殊的方法都被用来模仿某个行为。例如，如果你想要为你的类使用x[key]这样的索引操作（就像列表和元组一样），那么你只需要实现<strong>getitem</strong>()方法就可以了。想一下，Python就是对list类这样做的！</p>
<p>下面这个表中列出了一些有用的特殊方法。如果你想要知道所有的特殊方法，你可以在《Python参考手册》中找到一个庞大的列表</p>
<p><strong>表15.1 一些特殊的方法</strong> </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>_<em>init_</em>(self,…)</td>
<td>这个方法在新建对象恰好要被返回使用之前被调用。</td>
</tr>
<tr>
<td>_<em>del_</em>(self)</td>
<td>恰好在对象要被删除之前调用。</td>
</tr>
<tr>
<td>_<em>str_</em>(self)</td>
<td>在我们对对象使用print语句或是使用str()的时候调用。</td>
</tr>
<tr>
<td>_<em>lt_</em>(self,other)</td>
<td>当使用 小于 运算符（&lt;）的时候调用。类似地，对于所有的运算符（+，&gt;等等）都有特殊的方法。</td>
</tr>
<tr>
<td>_<em>getitem_</em>(self,key)</td>
<td>使用x[key]索引操作符的时候调用。</td>
</tr>
<tr>
<td>_<em>len_</em>(self)</td>
<td>对序列对象使用内建的len()函数的时候调用。</td>
</tr>
</tbody>
</table>
<h2 id="单语句块">单语句块</h2><p>现在，你已经很深刻地理解了每一个语句块是通过它的缩进层次与其它块区分开来的。然而这在大多数情况下是正确的，但是并非100％的准确。如果你的语句块只包含一句语句，那么你可以在条件语句或循环语句的同一行指明它。下面这个例子清晰地说明了这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span>flag = <span class="keyword">True</span></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="keyword">if</span> flag: <span class="keyword">print</span> <span class="string">'Yes'</span></span><br><span class="line">...</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<p>就如你所看见的，单个语句被直接使用而不是作为一个独立的块使用。虽然这样做可以使你的程序变得 小一些 ，但是除了检验错误之外我强烈建议你不要使用这种缩略方法。不使用它的一个主要的理由是一旦你使用了恰当的缩进，你就可以很方便地添加一个额外的语句。</p>
<p>另外，注意在使用交互模式的Python解释器的时候，它会通过恰当地改变提示符来帮助你输入语句。在上面这个例子中，当你输入了关键字if之后，Python解释器把提示符改变为…以表示语句还没有结束。在这种情况下，我们按回车键用来确认语句已经完整了。然后，Python完成整个语句的执行，并且返回原来的提示符并且等待下一句输入。</p>
<h2 id="列表综合">列表综合</h2><p>通过列表综合，可以从一个已有的列表导出一个新的列表。例如，你有一个数的列表，而你想要得到一个对应的列表，使其中所有大于2的数都是原来的2倍。对于这种应用，列表综合是最理想的方法。</p>
<h3 id="使用列表综合">使用列表综合</h3><p><strong>例15.1 使用列表综合</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: list_comprehension.py</span></span><br><span class="line"></span><br><span class="line">listone = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">listtwo = [<span class="number">2</span>*i <span class="keyword">for</span> i <span class="keyword">in</span> listone <span class="keyword">if</span> i &gt; <span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> listtwo</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/list_comprehension.py" target="_blank" rel="external">code/list_comprehension.py</a>）</p>
<h3 id="输出-41">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python list_comprehension<span class="class">.py</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-39">它如何工作</h3><p>这里我们为满足条件（if i &gt; 2）的数指定了一个操作（2*i），从而导出一个新的列表。注意原来的列表并没有发生变化。在很多时候，我们都是使用循环来处理列表中的每一个元素，而使用列表综合可以用一种更加精确、简洁、清楚的方法完成相同的工作。</p>
<h2 id="在函数中接收元组和列表">在函数中接收元组和列表</h2><p>当要使函数接收元组或字典形式的参数的时候，有一种特殊的方法，它分别使用<em>和*</em>前缀。这种方法在函数需要获取可变数量的参数的时候特别有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">powersum</span><span class="params">(power, *args)</span>:</span></span><br><span class="line"><span class="prompt">... </span>    <span class="string">'''Return the sum of each argument raised to specified power.'''</span></span><br><span class="line"><span class="prompt">... </span>    total = <span class="number">0</span></span><br><span class="line"><span class="prompt">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line"><span class="prompt">... </span>         total += pow(i, power)</span><br><span class="line"><span class="prompt">... </span>    <span class="keyword">return</span> total</span><br><span class="line">...</span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>powersum(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="prompt">&gt;&gt;&gt; </span>powersum(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>由于在args变量前有<em>前缀，所有多余的函数参数都会作为一个元组存储在args中。如果使用的是*</em>前缀，多余的参数则会被认为是一个字典的键/值对。</p>
<h2 id="lambda形式">lambda形式</h2><p>lambda语句被用来创建新的函数对象，并且在运行时返回它们。<br><strong>例15.2 使用lambda形式</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># Filename: lambda.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_repeater</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> s: s*n</span><br><span class="line"></span><br><span class="line">twice = make_repeater(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> twice(<span class="string">'word'</span>)</span><br><span class="line"><span class="keyword">print</span> twice(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>（源文件：<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/code/lambda.py" target="_blank" rel="external">code/lambda.py</a>）</p>
<h3 id="输出-42">输出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python lambda<span class="class">.py</span></span><br><span class="line">wordword</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="它如何工作-40">它如何工作</h3><p>这里，我们使用了make_repeater函数在运行时创建新的函数对象，并且返回它。lambda语句用来创建函数对象。本质上，lambda需要一个参数，后面仅跟单个表达式作为函数体，而表达式的值被这个新建的函数返回。注意，即便是print语句也不能用在lambda形式中，只能使用表达式。</p>
<h2 id="exec和eval语句">exec和eval语句</h2><p>exec语句用来执行储存在字符串或文件中的Python语句。例如，我们可以在运行时生成一个包含Python代码的字符串，然后使用exec语句执行这些语句。下面是一个简单的例子。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; exec <span class="string">'print "Hello World"'</span></span><br><span class="line"><span class="constant">Hello</span> <span class="constant">World</span></span><br></pre></td></tr></table></figure>
<p>eval语句用来计算存储在字符串中的有效Python表达式。下面是一个简单的例子。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">eval</span><span class="params">(<span class="string">'2*3'</span>)</span></span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="assert语句">assert语句</h2><p>assert语句用来声明某个条件是真的。例如，如果你非常确信某个你使用的列表中至少有一个元素，而你想要检验这一点，并且在它非真的时候引发一个错误，那么assert语句是应用在这种情形下的理想语句。当assert语句失败的时候，会引发一个AssertionError。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="prompt">&gt;&gt;</span>&gt; mylist = [<span class="string">'item'</span>]</span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; assert len(mylist) &gt;= <span class="number">1</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; mylist.pop()</span><br><span class="line"><span class="string">'item'</span></span><br><span class="line"><span class="prompt">&gt;&gt;</span>&gt; assert len(mylist) &gt;= <span class="number">1</span></span><br><span class="line"><span class="constant">Traceback</span> (most recent call last)<span class="symbol">:</span></span><br><span class="line">  <span class="constant">File</span> <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line"><span class="constant">AssertionError</span></span><br></pre></td></tr></table></figure>
<h2 id="repr函数">repr函数</h2><p>repr函数用来取得对象的规范字符串表示。反引号（也称转换符）可以完成相同的功能。注意，在大多数时候有eval(repr(object)) == object。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="tag">i</span> = []</span><br><span class="line">&gt;&gt;&gt; <span class="tag">i</span>.<span class="function"><span class="title">append</span><span class="params">(<span class="string">'item'</span>)</span></span></span><br><span class="line">&gt;&gt;&gt; `i`</span><br><span class="line"><span class="string">"['item']"</span></span><br><span class="line">&gt;&gt;&gt; <span class="function"><span class="title">repr</span><span class="params">(i)</span></span></span><br><span class="line"><span class="string">"['item']"</span></span><br></pre></td></tr></table></figure>
<p>基本上，repr函数和反引号用来获取对象的可打印的表示形式。你可以通过定义类的<strong>repr</strong>方法来控制你的对象在被repr函数调用的时候返回的内容。</p>
<h2 id="概括-14">概括</h2><p>在这一章中，我们又学习了一些Python的特色，然而你可以肯定我们并没有学习完Python的所有特色。不过，到目前为止，我们确实已经学习了绝大多数你在实际中会使用的内容。这些已经足以让你去创建任何程序了。</p>
<p>接下来，我们会讨论一下如何进一步深入探索Python。</p>
<h1 id="接下来学习什么？">接下来学习什么？</h1><p>如果你已经完全读完了这本书并且也实践着编写了很多程序，那么你一定已经能够非常熟练自如地使用Python了。你可能也已经编写了一些Python程序来尝试练习各种Python技能和特性。如果你还没有那样做的话，那么你一定要快点去实践。现在的问题是“接下来学习什么？”。</p>
<p>我会建议你先解决这样一个问题：创建你自己的命令行 地址簿 程序。在这个程序中，你可以添加、修改、删除和搜索你的联系人（朋友、家人和同事等等）以及它们的信息（诸如电子邮件地址和/或电话号码）。这些详细信息应该被保存下来以便以后提取。</p>
<p>思考一下我们到目前为止所学的各种东西的话，你会觉得这个问题其实相当简单。如果你仍然希望知道该从何处入手的话，那么这里也有一个提示。</p>
<p>提示（其实你不应该阅读这个提示） 创建一个类来表示一个人的信息。使用字典储存每个人的对象，把他们的名字作为键。使用cPickle模块永久地把这些对象储存在你的硬盘上。使用字典内建的方法添加、删除和修改人员信息。</p>
<p>一旦你完成了这个程序，你就可以说是一个Python程序员了。现在，请立即寄一封信给我感谢我为你提供了这本优秀的教材吧。是否告知我，如你所愿，但是我确实希望你能够告诉我。</p>
<p>这里有一些继续你的Python之路的方法：</p>
<h2 id="图形软件">图形软件</h2><p>使用Python的GUI库——你需要使用这些库来用Python语言创建你自己的图形程序。使用GUI库和它们的Python绑定，你可以创建你自己的IrfanView、Kuickshow软件或者任何别的类似的东西。绑定让你能够使用Python语言编写程序，而使用的库本身是用C、C++或者别的语言编写的。</p>
<p>有许多可供选择的使用Python的GUI：</p>
<ul>
<li><p>PyQt 这是Qt工具包的Python绑定。Qt工具包是构建KDE的基石。Qt，特别是配合Qt Designer和出色的Qt文档之后，它极其易用并且功能非常强大。你可以在Linux下免费使用它，但是如果你在Windows下使用它需要付费。使用PyQt，你可以在Linux/Unix上开发免费的（GPL约定的）软件，而开发具产权的软件则需要付费。一个很好的PyQt资源是<a href="http://www.opendocs.org/pyqt/" target="_blank" rel="external">《使用Python语言的GUI编程：Qt版》</a>请查阅<a href="http://www.riverbankcomputing.co.uk/pyqt/index.php" target="_blank" rel="external">官方主页</a>以获取更多详情。</p>
</li>
<li><p>PyGTK 这是GTK+工具包的Python绑定。GTK+工具包是构建GNOME的基石。GTK+在使用上有很多怪癖的地方，不过一旦你习惯了，你可以非常快速地开发GUI应用程序。Glade图形界面设计器是必不可少的，而文档还有待改善。GTK+在Linux上工作得很好，而它的Windows接口还不完整。你可以使用GTK+开发免费和具有产权的软件。请查阅<a href="http://www.pygtk.org/" target="_blank" rel="external">官方主页</a>以获取更多详情。</p>
</li>
<li><p>wxPython 这是wxWidgets工具包的Python绑定。wxPython有与它相关的学习方法。它的可移植性极佳，可以在Linux、Windows、Mac甚至嵌入式平台上运行。有很多wxPython的IDE，其中包括GUI设计器以及如<a href="http://spe.pycs.net/" target="_blank" rel="external">SPE（Santi’s Python Editor）</a>和<a href="http://wxglade.sourceforge.net/" target="_blank" rel="external">wxGlade</a>那样的GUI开发器。你可以使用wxPython开发免费和具有产权的软件。请查阅<a href="http://www.wxpython.org/" target="_blank" rel="external">官方主页</a>以获取更多详情。</p>
</li>
<li><p>TkInter 这是现存最老的GUI工具包之一。如果你使用过IDLE，它就是一个TkInter程序。在<a href="http://www.pythonware.com/library/tkinter/introduction/index.htm" target="_blank" rel="external">PythonWare.org</a>上的TkInter文档是十分透彻的。TkInter具备可移植性，可以在Linux/Unix和Windows下工作。重要的是，TkInter是标准Python发行版的一部分。</p>
</li>
</ul>
<p>要获取更多选择，请参阅<a href="http://www.python.org/cgi-bin/moinmoin/GuiProgramming" target="_blank" rel="external">Python.org上的GUI编程wiki页</a>。</p>
<h3 id="GUI工具概括">GUI工具概括</h3><p>不幸的是，并没有单一的标准Python GUI工具。我建议你根据你的情况在上述工具中选择一个。首要考虑的因素是你是否愿意为GUI工具付费。其次考虑的是你是想让你的程序运行在Linux下、Windows下还是两者都要。第三个考虑因素根据你是Linux下的KDE用户还是GNOME用户而定。</p>
<blockquote>
<p><strong>未来的章节</strong></p>
<p>我打算为本书编写一或两个关于GUI编程的章节。我可能会选择wxPython作为工具包。如果你想要表达你对这个主题的意见，请加入<a href="http://lists.ibiblio.org/mailman/listinfo/byte-of-python" target="_blank" rel="external">byte-of-python</a>邮件列表。在这个邮件列表中，读者会与我讨论如何改进本书。</p>
</blockquote>
<h2 id="探索更多内容">探索更多内容</h2><ul>
<li><p>Python标准库是一个丰富的库，在大多数时候，你可以在这个库中找到你所需的东西。这被称为Python的“功能齐全”理念。我强烈建议你在开始开发大型Python程序之前浏览一下<a href="http://docs.python.org/" target="_blank" rel="external">Python标准文档</a>。</p>
</li>
<li><p><a href="http://www.python.org/" target="_blank" rel="external">Python.org</a>——Python编程语言的官方主页。你可以在上面找到Python语言和解释器的最新版本。另外还有各种邮件列表活跃地讨论Python的各方面内容。</p>
</li>
<li><p>comp.lang.python是讨论Python语言的世界性新闻组。你可以把你的疑惑和询问贴在这个新闻组上。可以使用<a href="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;group=comp.lang.python" target="_blank" rel="external">Google群</a>在线访问这个新闻组，或加入作为新闻组镜像的<a href="http://mail.python.org/mailman/listinfo/python-list" target="_blank" rel="external">邮件列表</a>。</p>
</li>
<li><p><a href="http://aspn.activestate.com/ASPN/Python/Cookbook/" target="_blank" rel="external">《Python实用大全》</a>是一个极有价值的秘诀和技巧集合，它帮助你解决某些使用Python的问题。这是每个Python用户必读的一本书。</p>
</li>
<li><p><a href="http://gnosis.cx/publish/tech_index_cp.html" target="_blank" rel="external">《迷人的Python》</a>是David Mertz编著的一系列优秀的Python相关文章。</p>
</li>
<li><p><a href="http://www.diveintopython.org/" target="_blank" rel="external">《深入理解Python》</a>是给有经验的Python程序员的一本很优秀的书。如果你已经完整地阅读了本书，那么我强烈建议你接下来阅读《深入理解Python》。它覆盖了包括XML处理、单元测试和功能性编程在内的广泛的主题。</p>
</li>
<li><p><a href="http://www.jython.org/" target="_blank" rel="external">Jython</a>是用Java语言实现的Python解释器。这意味着你可以用Python语言编写程序而同时使用Java库！Jython是一个稳定成熟的软件。如果你也是一个Java程序员，我强烈建议你尝试一下Jython。</p>
</li>
<li><p><a href="http://www.ironpython.com/" target="_blank" rel="external">IronPython</a>是用C#语言实现的Python解释器，可以运行在.NET、Mono和DotGNU平台上。这意味着你可以用Python语言编写程序而使用.NET库以及其他由这三种平台提供的库！IronPython还只是一个前期alpha测试软件，现在还只适合用来进行试验。Jim Hugunin，IronPython的开发者，已经加入了微软公司，将在将来全力开发一个完整版本的IronPython。</p>
</li>
<li><p><a href="http://www.caddr.com/code/lython/" target="_blank" rel="external">Lython</a>是Python语言的Lisp前段。它类似于普通的Lisp语言，会被直接编译为Python字节码，这意味着它能与我们普通的Python代码协同工作。</p>
</li>
<li><p>另外还有很多很多的Python资源。其中比较有趣的有<a href="http://www.pythonware.com/daily/" target="_blank" rel="external">Daily Python-URL</a>!，它使你保持与Python的最新进展同步。另外还有<a href="http://www.vex.net/parnassus/" target="_blank" rel="external">Vaults of Parnassus</a>、<a href="http://www.onlamp.com/python/" target="_blank" rel="external">ONLamp.com Python DevCenter</a>、<a href="http://dirtsimple.org/" target="_blank" rel="external">dirtSimple.org</a>、<a href="http://pythonnotes.blogspot.com/" target="_blank" rel="external">Python Notes</a>等等。</p>
</li>
</ul>
<h2 id="概括-15">概括</h2><p>现在，我们已经来到了本书的末尾，但是就如那句名言，这只是 开始的结束 ！你现在是一个满怀渴望的Python用户，毫无疑问你准备用Python解决许多问题。你可以使你的计算机自动地完成许多先前无法想象的工作或者编写你自己的游戏，以及更多别的什么东西。所以，请出发吧！</p>
<h1 id="附录A_自由&amp;开放源码软件（FLOSS）">附录A 自由&amp;开放源码软件（FLOSS）</h1><p>FLOSS基于社区的概念，而它本身基于共享，特别是知识共享的概念。FLOSS可以免费使用、修改和再发行。</p>
<p>如果你已经读了本书，那么你一定熟悉FLOSS，因为你一直在使用Python！</p>
<p>如果你想要了解更多的FLOSS，你可以探索下面这个列表中的软件。我列出了一些最著名的FLOSS以及那些可以跨平台（即在Linux、Windows等）工作的FLOSS。这样你无需马上切换到Linux就可以尝试使用这些软件了， 尽管你最终一定会转到Linux上的 。</p>
<ul>
<li><p>Linux 这是一个正在慢慢被世界接纳的FLOSS操作系统！它最初由Linus Torvalds在学生时候开发。现在，它已经可以与微软Windows相匹敌。最新的2.6版本核心，无论从速度、稳定性还是扩展性角度来说，都是一个巨大的突破。【<a href="http://www.kernel.org/" target="_blank" rel="external">Linux核心</a>】</p>
</li>
<li><p>Knoppix 这是一个仅仅在CD上运行的Linux发行版！它不需要安装——你只需要重新启动你的计算机，把CD放入光驱，就可以开始使用一个完全的Linux发行版了！你可以使用所有的随标准Linux发行版发行的FLOSS，如运行Python程序、编译C程序、看电影等等。然后再次重启你的计算机，取出CD，就可以使用你现有的操作系统了，就好像什么都没有发生过一样。【<a href="http://www.knopper.net/" target="_blank" rel="external">Knoppix</a>】</p>
</li>
<li><p>Fedora 这是一个由社区开发维护的发行版，由Red Hat公司赞助。它是最流行的Linux发行版之一。它包含Linux核心、KDE、GNOME和XFCE桌面以及众多的FLOSS，而所有这些都易于安装、易于使用。</p>
</li>
<li><p>如果你担心你是一个完全的Linux生手，那么我推荐你尝试Mandrake Linux。最新发布Mandrake 10.1确实很棒。【<a href="http://fedora.redhat.com/" target="_blank" rel="external">Fedora Linux</a>、<a href="http://www.mandrakelinux.com/" target="_blank" rel="external">Mandrake Linux</a>】</p>
</li>
<li><p>OpenOffice.org 这是一个优秀的办公套件，它基于Sun Microsystems的StarOffice软件。OpenOffice由文本编写器、演讲辅助、电子表格和绘图组件等等组成。它甚至可以方便地打开和编辑微软Word和PowerPoint文件。它可以在几乎所有平台上运行。即将推出的OpenOffice 2.0有一些重大的改进。【<a href="http://www.openoffice.org/" target="_blank" rel="external">OpenOffice</a>】</p>
</li>
<li><p>Mozilla Firefox 这是被认为可以在未来几年击败Internet Explorer（仅按照市场份额计算）的下一代网络浏览器。它极快，它的一些合理的、令人印象深刻的特性广受好评。它的扩展理念允许在它上面添加各种功能。</p>
</li>
<li><p>它的姐妹产品Thunderbird是一个优秀的电子邮件客户端，使阅读电子邮件变得十分快捷。【<a href="http://www.mozilla.org/products/firefox" target="_blank" rel="external">Mozilla Firefox</a>、<a href="http://www.mozilla.org/products/thunderbird" target="_blank" rel="external">Mozilla Thunderbird</a>】</p>
</li>
<li><p>Mono 这是一个微软.NET平台的开源实现。它使我们可以在Linux、Windows、FreeBSD、Mac OS和许多其他平台上创建和运行.NET程序。Mono执行CLI和C#的ECMA标准，这个标准已经由微软、英特尔和惠普提交称为一个开放标准。这也是迈向ISO标准的一步。</p>
</li>
<li><p>目前，Mono包含一个完整的C#主控制台（它本身也由C#编写！）、一个具备完整特性的ASP.NET实现、许多数据库ADO.NET提供器另外还有每天不断改善和增加的新特性。【<a href="http://www.mono-project.com/" target="_blank" rel="external">Mono</a>、<a href="http://www.ecma-international.org/" target="_blank" rel="external">ECMA</a>、<a href="http://www.microsoft.com/net" target="_blank" rel="external">Microsoft .NET</a>】</p>
</li>
<li><p>Apache网络服务器 这是最流行的开源网络服务器。事实上，它是地球上最流行的网络服务器！它运行着几乎60％的网站。对——Apache处理的网站比它所有的竞争对手（包括微软IIS）之和还要多。【<a href="http://www.apache.org/" target="_blank" rel="external">Apache</a>】</p>
</li>
<li><p>MySQL 这是一个极其流行的开源数据库服务器。它以它的快速最为著名。在它的最新版本中又添加了更多的特性。【<a href="http://www.mysql.com/" target="_blank" rel="external">MySQL</a>】</p>
</li>
<li><p>MPlayer 这是一个视频播放器，可以播放DivX、MP3、Ogg、VCD、DVD……谁说开源软件就不能具有趣味呢？【<a href="http://www.mplayerhq.hu/" target="_blank" rel="external">MPlayer</a>】</p>
</li>
<li><p>Movix 这是一个Linux发行版，它基于Knoppix仅仅在CD上运行用来播放电影！你可以创建Movix的CD。它们是可启动的CD，当你重启计算机的时候，放入CD，电影就会自己开始播放！使用Movix观看电影，你甚至不需要硬盘。【<a href="http://movix.sourceforge.net/" target="_blank" rel="external">Movix</a>】</p>
</li>
</ul>
<p>上面这个列表只是希望给你一个大概的印象——还有很多别的优秀FLOSS，比如Perl语言、PHP语言、Drupal网站内容管理系统、PostgreSQL数据库服务器、TORCS赛车游戏、KDevelop IDE、Anjuta IDE、Xine——电影播放器、VIM编辑器、Quanta+编辑器、XMMS音频播放器、GIMP图像编辑程序……这个列表可以一直继续下去。</p>
<p>访问下述网站以获取更多FLOSS信息：</p>
<ul>
<li><p><a href="http://www.sourceforge.net/" target="_blank" rel="external">SourceForge</a></p>
</li>
<li><p><a href="http://www.freshmeat.net/" target="_blank" rel="external">FreshMeat</a></p>
</li>
<li><p><a href="http://www.kde.org/" target="_blank" rel="external">KDE</a></p>
</li>
<li><p><a href="http://www.gnome.org/" target="_blank" rel="external">GNOME</a></p>
</li>
</ul>
<p>要获知FLOSS世界的最新进展，请访问下述网站：</p>
<ul>
<li><p><a href="http://www.osnews.com/" target="_blank" rel="external">OSNews</a></p>
</li>
<li><p><a href="http://www.linuxtoday.com/" target="_blank" rel="external">LinuxToday</a></p>
</li>
<li><p><a href="http://www.newsforge.com/" target="_blank" rel="external">NewsForge</a></p>
</li>
<li><p><a href="http://www.swaroopch.info/blog" target="_blank" rel="external">SwaroopCH’s blog</a></p>
</li>
</ul>
<p>那么，现在就出发去探索广博、免费、开放的FLOSS世界了吧！</p>
<h1 id="附录B_关于本书">附录B 关于本书</h1><h2 id="后记">后记</h2><p>我在编写本书时使用的几乎所有软件都是 免费开放源码的软件 。在编写本书的第一个草稿的时候，我使用的是Red Hat 9.0 Linux，而现在第六次改写的时候，使用的是Fedora Core 3 Linux。</p>
<p>最初，我使用KWord编写本书（在前言的本书的由来中已经介绍了）。后来，我开始使用DocBook XML和Kate，但是我发现这样太乏味。所以，我开始使用OpenOffice，它对格式的控制以及生成PDF的能力是很棒的。但是它生成的HTML过于庞大。最后，我发现了XEmacs，于是我又开始重新使用DocBook XML来编写本书，并且那时我打算把这个模式作为将来长期的方案。在这个最新的第六次重写时，我决定使用Quanta+来编辑。</p>
<p>我使用了标准的XSL样式表，它随Fedora Core 3 Linux附带。另外，我也使用了标准的默认字体。我编写了一个CSS文件来为HTML页增加颜色和样式。同时，我还用Python语言编写了一个粗劣的词汇分析器，它自动为书中所有的程序进行语法加亮。</p>
<h2 id="关于作者">关于作者</h2><p>Swaroop C. H. 在Yahoo!驻印度班加罗尔的办事处工作，他十分热爱他的工作。他目前在技术领域的兴趣有：包括Linux、DotGNU、Qt和MySQL在内的FLOSS、Python和C#编程语言。另外他在业余时间编写一些如本书这样的教材和其他软件，以及编写他的网上日记。他的其他爱好有咖啡、Robert Ludlum的小说、远足和政治等。</p>
<p>如果你有兴趣了解他的更多故事，可以在<a href="http://www.swaroopch.info/" target="_blank" rel="external">www.swaroopch.info</a>上查看他的网上日记。</p>
<h2 id="关于译者">关于译者</h2><p>沈洁元 目前是上海交通大学无线通信研究所的一名硕士研究生。他现在的研究领域主要在多载波CDMA系统的同步、信道估计、多用户检测等方面。Python语言（和Numeric库）是他目前在进行仿真和其他科研工作时使用的主要编程语言。在业余时间，他乐衷于各种FLOSS，如FreeBSD操作系统、PyGTK等等。电影、F1赛车和网球也是他的兴趣爱好。</p>
<h2 id="关于简体中文译本">关于简体中文译本</h2><p>我在半年多前开始学习使用Python编程语言。正如Swaroop在本书中所说的那样，它很快就成为“我最喜欢的编程语言”。目前我的几乎所有编程工作都使用Python。从我的切身体会来说，Python最大的特点就是易懂、易用、高效率。我相信，如果你已经学完了本书，并且尝试着编写了一些程序后，你一定会有相同的感受。</p>
<p>Swaroop C. H.的这本书是我学习Python时的第一本教材。它简单明晰，可以在最短的时间内把你领进Python的世界。它不是很长，但是覆盖了几乎所有重要的Python知识。在第一次读本书的时候，我就深切的感到这是给Python初学者的一本极佳教材，应该是每一位Python初学者的第一本教材。</p>
<p>我利用业余时间翻译了这本教材的简体中文译本。一方面是为了感谢Swaroop给我们带来了那么好的一本教材，同时也是为了把本书介绍给更多的中国读者，希望让Python在中国更加普及。如果读了本书之后，你开始将Python应用于你的工作学习，这将是我和Swaroop以及其他Python用户的荣幸。如果你在学习和使用Python的过程中，遇到任何问题，你一定要试试使用Python的<a href="http://mail.python.org/mailman/listinfo" target="_blank" rel="external">邮件列表资源</a>。你一定会得到世界各地的Python高手的热情帮助。</p>
<p>本书的英文原名为《A Byte of Python》。经过与Swaroop的探讨，在翻译时，我把书名定为《简明 Python 教程》，以充分体现本书区别于其他Python教材的鲜明特色。在翻译这本简体中文译本时，我力求准确清晰。在原书中个别不甚清晰的地方，都与作者进行讨论后再行翻译。另外，在这本简体中文译本中，我还为书中所有的程序例子配上了源代码，并且在书后附上了中英对照的<a href="http://woodpecker.org.cn/abyteofpython_cn/chinese/apcs02.html" target="_blank" rel="external">术语表</a>，以便读者以后继续学习其他Python英文资料。</p>
<p>本译本作为原书的派生作品，依照<a href="http://www.creativecommons.cn/licenses/by-nd-nc/1.0/" target="_blank" rel="external">创作公用约定（署名-非派生作品-非商业用途）</a>发布。简单地说，你只要署上我的名字，就可以免费复制、分发和展示本译本。未得到我的允许，你禁止把本译本用于商业目的，也不能再在本译本的基础上修改、派生新的作品。</p>
<p>如果你对本书和译本有任何批评和建议，十分欢迎你与我联系：<code>orion_val@163.com</code>。</p>
<h1 id="附录C_修订记录">附录C 修订记录</h1><h2 id="时间表">时间表</h2><p>本文档在2005年1月13日4点02分生成。</p>
<h3 id="修订记录">修订记录</h3><table>
<thead>
<tr>
<th>版本</th>
<th>日期</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.20版</td>
<td>2005年1月13日</td>
</tr>
<tr>
<td></td>
<td>使用FC3上的Quanta+的完全重写。做了许多修正和更新。添加了许多新的例子。重写了我的DocBook设置。</td>
</tr>
<tr>
<td>1.15版</td>
<td>2004年3月28日</td>
</tr>
<tr>
<td></td>
<td>少量修订。</td>
</tr>
<tr>
<td>1.12版</td>
<td>2004年3月16日</td>
</tr>
<tr>
<td>添加修正了一些内容。</td>
<td></td>
</tr>
<tr>
<td>1.10版</td>
<td>2004年3月9日</td>
</tr>
<tr>
<td>感谢我的热情读者的帮助，我对更多的笔误做了修改。</td>
<td></td>
</tr>
<tr>
<td>1.00版</td>
<td>2004年3月8日</td>
</tr>
<tr>
<td>在从读者处获得了大量反馈和建议之后，我对本书的内容做了重要的修订，并且改正了一些笔误。</td>
<td></td>
</tr>
<tr>
<td>0.99版</td>
<td>2004年2月22日</td>
</tr>
<tr>
<td>增加了模块一章。增加了对可变数目函数参数的详细介绍。</td>
<td></td>
</tr>
<tr>
<td>0.98版</td>
<td>2004年2月16日</td>
</tr>
<tr>
<td>编写了一个Python脚本和CSS样式表来改善XHTML的输出效果。其中包括一个功能还很拙劣的词汇分析器，用来自动地为程序做类似于VIM地语法加亮。</td>
<td></td>
</tr>
<tr>
<td>0.97版</td>
<td>2004年2月13日</td>
</tr>
<tr>
<td>（再次）使用DocBook XML完全重写。本书改进了许多——更加有条理和易读。</td>
<td></td>
</tr>
<tr>
<td>0.93版</td>
<td>2004年1月25日</td>
</tr>
<tr>
<td>增加了关于IDLE的介绍以及更多Windows®相关的话题。</td>
<td></td>
</tr>
<tr>
<td>0.92版</td>
<td>2004年1月5日</td>
</tr>
<tr>
<td>修改了几个例子。</td>
<td></td>
</tr>
<tr>
<td>0.91版</td>
<td>2003年12月30日</td>
</tr>
<tr>
<td>修正了排版错误。改进了许多章节的内容。</td>
<td></td>
</tr>
<tr>
<td>0.90版</td>
<td>2003年12月18日</td>
</tr>
<tr>
<td>增加了2章。使用OpenOffice格式修订。</td>
<td></td>
</tr>
<tr>
<td>0.60版</td>
<td>2003年11月21日</td>
</tr>
<tr>
<td>完全地重写和扩展。</td>
<td></td>
</tr>
<tr>
<td>0.20版</td>
<td>2003年11月20日</td>
</tr>
<tr>
<td>修改了一些排版错误和其他错误。</td>
<td></td>
</tr>
<tr>
<td>0.15版</td>
<td>2003年11月20日</td>
</tr>
<tr>
<td>改用DocBook XML。</td>
<td></td>
</tr>
<tr>
<td>0.10版</td>
<td>2003年11月14日</td>
</tr>
<tr>
<td>最初使用KWord编写的草稿。</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="术语表">术语表</h2><table>
<thead>
<tr>
<th>EN</th>
<th>CN</th>
</tr>
</thead>
<tbody>
<tr>
<td>argument</td>
<td>实参</td>
</tr>
<tr>
<td>attribute</td>
<td>属性</td>
</tr>
<tr>
<td>base class</td>
<td>基本类</td>
</tr>
<tr>
<td>block</td>
<td>块</td>
</tr>
<tr>
<td>character</td>
<td>字符</td>
</tr>
<tr>
<td>class</td>
<td>类</td>
</tr>
<tr>
<td>comment</td>
<td>注释</td>
</tr>
<tr>
<td>complex number</td>
<td>复数</td>
</tr>
<tr>
<td>derived class</td>
<td>导出类</td>
</tr>
<tr>
<td>dictionary</td>
<td>字典</td>
</tr>
<tr>
<td>escape sequence</td>
<td>转义符</td>
</tr>
<tr>
<td>exception</td>
<td>异常</td>
</tr>
<tr>
<td>expression</td>
<td>表达式</td>
</tr>
<tr>
<td>field</td>
<td>域</td>
</tr>
<tr>
<td>float</td>
<td>浮点数</td>
</tr>
<tr>
<td>function</td>
<td>函数</td>
</tr>
<tr>
<td>identifier</td>
<td>标识符</td>
</tr>
<tr>
<td>indentation</td>
<td>缩进</td>
</tr>
<tr>
<td>indexing</td>
<td>索引</td>
</tr>
<tr>
<td>instance</td>
<td>实例</td>
</tr>
<tr>
<td>integer</td>
<td>整数</td>
</tr>
<tr>
<td>list</td>
<td>列表</td>
</tr>
<tr>
<td>list comprehension</td>
<td>列表综合</td>
</tr>
<tr>
<td>literal constant</td>
<td>字面意义上的常量</td>
</tr>
<tr>
<td>logical line</td>
<td>逻辑行</td>
</tr>
<tr>
<td>long integer</td>
<td>长整数</td>
</tr>
<tr>
<td>method</td>
<td>方法</td>
</tr>
<tr>
<td>module</td>
<td>模块</td>
</tr>
<tr>
<td>namespace</td>
<td>名称空间</td>
</tr>
<tr>
<td>object</td>
<td>对象</td>
</tr>
<tr>
<td>operand</td>
<td>操作数</td>
</tr>
<tr>
<td>operator</td>
<td>运算符</td>
</tr>
<tr>
<td>parameter</td>
<td>形参</td>
</tr>
<tr>
<td>pickle</td>
<td>储存器</td>
</tr>
<tr>
<td>physical line</td>
<td>物理行</td>
</tr>
<tr>
<td>sequence</td>
<td>序列</td>
</tr>
<tr>
<td>shebang line</td>
<td>组织行</td>
</tr>
<tr>
<td>slicing</td>
<td>切片</td>
</tr>
<tr>
<td>statement</td>
<td>语句</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>subclass</td>
<td>子类</td>
</tr>
<tr>
<td>superclass</td>
<td>超类</td>
</tr>
<tr>
<td>tuple</td>
<td>元组</td>
</tr>
<tr>
<td>type</td>
<td>类型</td>
</tr>
<tr>
<td>variable</td>
<td>变量 </td>
</tr>
</tbody>
</table>
 
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://qinyuanpei.com/wiki/python.html" data-title="Python快速教程 | 秦元培" data-tsina="1278609231" class="share clearfix">
	  </div>
	
	</div>


</footer>

  	       
	</article>
	
	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="wiki/python.html" data-title="Python快速教程" data-url="http://qinyuanpei.com/wiki/python.html"></div>
</section>


</div>  
        </div>
        <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p>  <br/>
			就像每一个时代里的人都觉得自己没有赶上一个好的时代一样。这里没有末路，你从不曾孤独。</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1278609231" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/qinyuanpei" target="_blank" class="icon-github" title="Github"></a>
		
		
		
		
		<a href="http://www.zhihu.com/people/qinyuanpei" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		<a href="mailto:qinyuanpei@163.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			

		

				<div class="cc-license">

          <p class="copyright">本作品由<a href="/about" target="_blank" title="秦元培">秦元培</a>创作，采用知识共享<a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
            <img src="/img/cc-by-nc-sa.svg" alt="Creative Commons" />
          </a>国际许可协议4.0进行许可<br></p>
        </div>
    

		<p class="copyright">
			Powered by <a href="http://hexo.io" target="_blank" title="hexo">Hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
			
				<a href="/about" target="_blank" title="秦元培">秦元培</a>
			
			<span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
		</p>
</div></footer>
        <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"qinyuanpei"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }

  //为了解决多说头像服务器奔溃手动替换头像
  var imgs = new Array();
  imgs[0] = 'http://img.blog.csdn.net/20151104153648246';
  imgs[1] = 'http://img.blog.csdn.net/20151104153658676';
  imgs[2] = 'http://img.blog.csdn.net/20151104153719133';
  imgs[3] = 'http://img.blog.csdn.net/20151104153730060';
  imgs[4] = 'http://img.blog.csdn.net/20151104153742180';
  imgs[5] = 'http://img.blog.csdn.net/20151104154610054';
  $('.ds-avatar img[src*="cdncache"]').each(function(){
    var rand = Math.floor(Math.random() * imgs.length);
    $(this).attr("src",imgs[rand]);
  });

}); 
</script>


<!-- Analytics Begin -->

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">

<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->



      </body>
     </html>
     
